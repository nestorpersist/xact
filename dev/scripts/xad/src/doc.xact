<section:top name="@x:Act Reference">
      <section:numbered name="Introduction">
	 <include name="overview1"/>
	 <section:numbered name="Examples">
	    <section:numbered name="About the Examples">
	       <p>
	       The following sections present a progressive series of simple
	       examples that introduce the &xact; language.
	       </p>
	       <p>
		  Clicking on many of the operators and names in the examples
		  will take you to their definition in the reference manual.
	       </p>
	       <p>
		  You can run example <@verb{"xxx"}/> with the following command line.
	       </p>
	       <p>
		  <@verb{"run example:xxx"}/>
	       </p>
	       <p>
		  If you want to single step the example with the debugger, use the following line.
	       </p>
	       <p>
		  <@verb{"run example:xxx debug"}/>
	       </p>
	    </section:numbered>
	    <section:example name="fact">
	       <p>
	       Here is a simple &xact; script for computing factorial.
	       </p>
	       <ecode name="fact"/>
	       <p>
		  When this script is run it produces the following output on <@verb{"STDOUT"}/>.
	       </p>
	       <@verb{"fact(1)=1
fact(2)=2
fact(3)=6
fact(4)=24
fact(5)=120
fact(6)=720
fact(7)=5040
fact(8)=40320
fact(9)=362880
fact(10)=3628800"}/>
	       <p>
		  &xact; commands all start with <@verb{"@x:"}/>.
		  The <@verb{"@"}/> indicates the start of a command.
		  This approach allows &xact; to have no reserved words.
		  The <@verb{"x:"}/> identifies a namespace (much as it does in XML).
		  The <@verb{"x"}/> namespace is predefined for &xact; commands.
		  &xact; allows other command sets to be defined, each with its
		  own namespace.
		  Note that the if-then-else involves two consecutive commands.
	       </p>
	       <p>
		  In the &xact; language every expression and command
		  has a value.
		  Some commands such as <ref:tag name="x:func"/> and <ref:tag name="x:var"/> produce
		  a <@icode{null}/> which is here discarded.
	       </p>
	       <p>
		  Expression prefix and infix operators are similar to those of Java with
		  a couple of exceptions.
		  Here <ref:inop name=":="/> is the assignment operator (rather than the <@verb{"="}/> used in Java).
	       </p>
	    </section:example>
	    <section:example name="FactHTML">
	       <p>
		  A common use for &xact; is to generate web pages.
		  The &xact; interpreter can be run under a web server as
		  either a <@verb{"CGI"}/> or as a <@verb{"servlet"}/>.
	       </p>
	       <p>
		  Here the previous factorial example has been modified to produce
		  XHTML output for displaying the result in a web browser.
	       </p>
	       <ecode name="FactHTML"/>
	       <p>
		  Note how the example contains XML to be added to the program output.
		  &xact; supports two syntax variants: the &xact; form that we saw in the
		  previous example and the a pure XML form.
		  This example combines the two forms.
	       </p>
	       <p>
		  An XML element is an alternative syntax for an &xact; syntax command.
		  The default rule for commands with no namespace or whose namespace is
		  not <@verb{"x:"}/> is to render that command/element.
		  Execution of an element to be rendered produces a string
		  representation of that element.
	       </p>
	    </section:example>
	    <section:example name="max">
	       <p>
	       &xact; is a scripting language and like most other scripting languages
	       (but unlike Java), &xact; is dynamically typed.
	       </p>
	       <ecode name="max"/>
	    </section:example>
	    <section:example name="FactTyped">
	       <p>
		  Even though &xact; is dynamically typed, it is possible to
		  specify types in a way similar to that of statically typed languages.
	       </p>
	       <ecode name="FactTyped"/>
	       <p>
		  The infix <ref:inop name="~"/> operator asserts that a name or expression has a specified type.
		  The prefix <ref:preop name="~"/> operator asserts that the
		  following <@icode{boolean}/> expression is <@icode{true}/>.
	       </p>
	    </section:example>
	    <section:example name="stack">
	       <p>
	          &xact; permits new abstract types to be defined.
	       </p>
	       <ecode name="stack"/>
	       <p>
		  The <ref:tag name="x:type"/> command defines data and operations associated
		  with the type (in this case there are none).
		  The immediately
		  following <ref:tag name="x:self"/> command defines data and operations associated
		  with instances of the type.
		  Those that are marked <@icode{visible}/> can be seen by user of the type
		  and its instances. Those not marked visible
		  (in this case <@icode{data}/> and <@icode{IsEmpty}/>) are not visible outside.
	       </p>
	       <p>
		  Note the assertions on several of the functions.
		  These are checked at the time the function is called.
	       </p>
	       <p>
		  Note that this is a parameterized type.
		  The stack element type is passed in as <@icode{elem}/>.
	       </p>
	    </section:example>
	    <section:example name="even">
	       <p>
	       &xact; does not support type inheritance.
	       Instead, an alterative mechanism called views are provided.
	       Here is a simple example that produces a view of the <@icode{int}/> type
	       that restricts the values to only those that are even.
	       </p>
	       <ecode name="even"/>
	       <p>
		  The special <@icode{"sys:Is"}/> function states what values
		  are "in" the view.
		  The <ref:inop name="/+"/> is the remainder operation.
	       </p>
	       <p>
		  The infix <ref:inop name="~"/> operation asserts
		  that its left operand has the type or view specified by the right operand
		  and returns the value of the left operand.
		  The infix <ref:inop name="?"/> operator tests if its left operand
		  has the type or view specified by the right operand.
	       </p>
	    </section:example>
	    <section:example name="StringNull">
	       <p>
		  Views can not only be used to narrow the value set
		  of a type, they can also be to expand a value set.
		  In &xact; (unlike Java), types do not automatically
		  permit a null value. The following example
		  shows a new view where values can be either strings or null.
	       </p>
	       <ecode name="StringNull"/>
	       <p>
		  Like types, operations can also be associated with view instances.
		  Invoking the operation requires that the view be specified
		  (following the <@verb{"#"}/>).
	       </p>
	       <p>
		  The special name <@icode{self}/> is automatically defined
		  inside <ref:tag name="x:self"/> commands and refers to
		  the current type or view instance.
		  It plays the same role as <@verb{"this"}/> does in Java.
	       </p>
	    </section:example>
	    <section:example name="incr">
	       <p>
		  &xact; uses a different mechanism for iterators than Java.
		  &xact; iterators are functions that take the body of the loop
		  as a function parameter.
	       </p>
	       <ecode name="incr"/>
	    </section:example>
	    <section:example name="merge">
	       <p>
		  &xact; provides threads and synchronization.
		  Here is an iterator that uses threads to merge two ordered sequences.
	       </p>
	       <ecode name="merge"/>
	       <p>
		  The <@icode{merge}/> iterator takes two other iterators as parameters.
		  It then starts a separate thread to run each of the two.
		  The main thread collects the results.
	       </p>
	       <p>
		  The <@icode{queue}/> type is used to synchronize threads.
		  One thread sends values to the queue and another thread
		  receives those values.
	       </p>
	    </section:example>
	    <section:example name="CntTag">
	       <p>
		  &xact; scripts can be parsed, manipulated, and then unparsed.
		  This makes it easy to write tools that work on &xact; scripts.
		  Since XML is a subset of the &xact; syntax, it is also easy
		  to write tools for XML.
	       </p>
	       <p>
		  The result of parsing an &xact; script is a <@icode{xdom}/> tree.
	       </p>
	       <p>
		  The following example counts the number of commands in itself.
		  It reads in a copy of itself, parses that copy to produce
		  a <@icode{xdom}/> tree, then walks that tree using a recursive iterator.
	       </p>
	       <ecode name="CntTag"/>
	       <p>
		  The <@icode{xdom:element}/> type is used to represent &xact; commands
		  and XML elements.
		  It also has views that enable it to be used as a record (<@icode{rec}/>)
		  or array (<@icode{array}/>).
	       </p>
	       <p>
		  The record dot qualification operation <@icode{r.x#rec}/> has a
		  generalized form <@icode{Dot(r,"x",rec)}/> that allows the component
		  name to be a computed value.
	       </p>
	    </section:example>
	 </section:numbered>
      </section:numbered>
      <include name="user"/>
      <section:numbered name="System Manual">
	 <section:numbered name="Installation">
	    <section:numbered name="Directories">
	       <p>
		  The &xact; files have the following directory structure.
	       </p>
	       <list:unordered>
		  <list:item>
		     <@verb{"xact/dev"}/>. Source file directories.
		     <list:unordered>
			<list:item>
			   <@verb{"xact/dev/src"}/>. Java source files.
			</list:item>
			<list:item>
			   <@verb{"xact/dev/script"}/>. &xact; scripts.
			</list:item>
			<list:item>
			   <@verb{"xact/dev/script/example"}/>. Examples includes in documentation.
			</list:item>
			<list:item>
			   <@verb{"xact/dev/script/library"}/>. &xact; libraries.
			</list:item>
			<list:item>
			   <@verb{"xact/dev/script/xad"}/>. These scripts are used to generate the &xact; documentation. These scripts 
                           and their input format are not documented and error checking is limited, so use at your own risk. 
			</list:item>
			<list:item>
			   <@verb{"xact/dev/script/xad/src"}/>. The orignal source files from which the &xact; documentation is generated.
                           Changes to &xact; documentation are made to these files not to the derived HTML files.
			</list:item>
			<list:item>
			   <@verb{"xact/dev/win"}/>. Windows scripts and commands for building and running &xact;.
			</list:item>
			<list:item>
			   <@verb{"xact/dev/mac"}/>. Mac OSX scripts and commands for building and running &xact;.
			</list:item>
		     </list:unordered>
		  </list:item>
		  <list:item>
		     <@verb{"xact/var"}/>. Derived file directories.
		     Files in these directories are are generated and should never be directly modified.
                     Section <ref:numbered name="Building"/> describes how they are built.
		     <list:unordered>
			<list:item>
			   <@verb{"xact/var/doc/doc"}/>. &xact; documentation.
			   Open <@verb{"index.html"}/> in a web browser.
			</list:item>
			<list:item>
			   <@verb{"xact/var/javadoc"}/>. Javadoc for the &xact; Java code.
			   Open <@verb{"index.html"}/> in a web browser.
			</list:item>
			<list:item>
			   <@verb{"xact/var/logs"}/>. Log files from running the &xact; interpreter
			   from the command line.
			</list:item>
			<list:item>
			   <@verb{"xact/var/weblogs"}/>. Log files from running the &xact; interpreter
			   from a web server.
			</list:item>
			<list:item>
			   <@verb{"xact/var/object"}/>. Class files from compiling the Java source files.
			</list:item>
			<list:item>
			   <@verb{"xact/var/xact.jar"}/>. The Java jar file that contains the &xact; interpreter.
			</list:item>
		     </list:unordered>
		  </list:item>
	       </list:unordered>
	    </section:numbered>
	    <section:numbered name="Path Setup">
	       <p>
		  &xact; commands need to know where to find various software upon
		  which they depend.
	       </p>
	       <p>
		  On Windows copy <@verb{"xact/dev/win/jrndef.bat"}/> to <@verb{"xact/def.bat"}/>.
		  You should then edit <@verb{"xact/def.bat"}/> to have the correct paths
		  for your machine. 
               </p>
	       <p>
		  On a Macintosh copy <@verb{"xact/dev/mac/macdef"}/> to <@verb{"xact/def"}/>.
		  You should then edit <@verb{"xact/def"}/> to have the correct paths
		  for your machine. 
	       </p>
	       <list:unordered>
		  <list:item>
		     <@verb{"XACT"}/>.
		     This should be the path for where you installed &xact;.
		  </list:item>
		  <list:item>
		     <@verb{"JAVA_HOME"}/>.
		     This should point to the Java JDK. Version should be at least <@verb{"1.5"}/>.
		  </list:item>
		  <list:item>
		     <@verb{"ANT_HOME"}/>.
		     Directory where ANT is installed.
		     You can get ANT from.
		     <p>
			<@a ref="http://ant.apache.org/"/>
		     </p>
		  </list:item>
		  <list:item>
		     <@verb{"BDB_JAR"}/>.
		     This should point to the jar file for Berkeley DB.
		     You want the Java API on the standard edition
		     (not the Java edition).
		     You can get this from.
		     <p>
			<@a ref="http://ant.apache.org/"/>
		     </p>
		  </list:item>
		  <list:item>
		     <@verb{"SERVLET_JAR"}/>.
		     This should point to a servlet Jar.
		     We run &xact; under Tomcat which includes
		     this jar file.
		     You can get Tomcat from.
		     <p>
			<@a ref="http://tomcat.apache.org/"/>
		     </p>
		     
		  </list:item>
	       </list:unordered>
	    </section:numbered>
	    <section:numbered name="Building">
	       <p>
		  On Windows, connect to <@verb{"xact/dev/win"}/>. 
	       </p>
	       <list:unordered>
		  <list:item>
		     To compile the &xact; interpreter issue the following commands.
		     <p>
			<@verb{"ant.bat"}/>
		     </p>
		     <p>
			<@verb{"jar.bat"}/>
		     </p>
		  </list:item>
		  <list:item>
		     To build the &xact; documentation issue the following command.
		     <p>
			<@verb{"run.bat xad:gen(doc)"}/>
		     </p>
		  </list:item>
		  <list:item>
		     To build the Javadoc issue the following command.
		     <p>
			<@verb{"javadoc.bat"}/>
		     </p>
		  </list:item>
	       </list:unordered>
	       <p>
		  On a Macintosh, connect to <@verb{"xact/dev/mac"}/>. 
	       </p>
	       <list:unordered>
		  <list:item>
		     To compile the &xact; interpreter issue the following commands.
		     <p>
			<@verb{"./ant"}/>
		     </p>
		     <p>
			<@verb{"./jar"}/>
		     </p>
		  </list:item>
		  <list:item>
		     To build the &xact; documentation issue the following command.
		     <p>
			<@verb{'./run "xad:gen(doc)"'}/>
		     </p>
		  </list:item>
		  <list:item>
		     To build the Javadoc issue the following command.
		     <p>
			<@verb{"./javadoc"}/>
		     </p>
		  </list:item>
	       </list:unordered>
	    </section:numbered>
            <section:numbered name="Support">
            <p>
              We can be contacted by email at <a ref="mailto:nestor@persist.com"/>. 
            </p>
            <p>
               We hope you find the &xact; system to be useful and interesting; but, 
               it is supplied as is with no guarantees of correctness or utility.
               Although we hope to incrementally improve the system, we make no promise that there will be
               additional updates or bug fixes.
               Full source is included, so you are free (subject to the license) to debug, modify, and improve the system.
            </p>
            <p>
               You can register your copy (if you want to receive notification of updates), report problems, 
               of suggest improvements by sending us email.
               When reporting bugs, please (if possible)
               include sample code that shows the bug. We also welcome code for improvements to the interpreter, libraries,
               and documentation and will consider them for inclusion in a future update.
            </p>
            <p>
               Please contact us if you have any interest in paid support or commercial uses not covered by the license.
            </p>
            </section:numbered>
	 </section:numbered>
	 <section:numbered name="Running">
	    <section:numbered name="Invoking Scripts">
	       An &xact; script can be run from the command line as follows.
	       <p>
		  <@verb{"cd xact/dev/win"}/>
	       </p>
	       <p>
		  <@verb{"run xxx opt"}/>
	       </p>
	       <p>
		  where <@verb{"xxx"}/> specifies the script
		  (and optionally parameters and other information to be passed)
		  and where <@verb{"opt"}/> is an optional list of
		  interpreter options.
	       </p>
	       <p>
	          Note on Windows if any of the command line arguments
		  contain either a <@verb{"&amp;"}/>
		  you should enclose that command line argument in 
		  double quotes.
	       </p>
	       <p>	
	          On a Macintosh arguments containing 
		  <@verb{"&amp;"}/> or <@verb{"()"}/> must be quoted.
	       </p>
	    </section:numbered>
	    <section:numbered name="Script Paths">
	       <p>
		  To run an &xact; <ref:nt name="script"/>,
		  you must know the script path for the file
		  that contains the script.
		  A script path is relative to the &xact; scripts
		  directory. By default this directory is at <@verb{"xact/var/scripts"}/>.
	       </p>
	       <p>
		  To run the script in <@verb{"xact/var/scripts/xxx.xact"}/> the
		  script path will be <@verb{"xxx"}/>.
		  To run the script in <@verb{"xact/var/scripts/xad/example/fact.xact"}/> the
		  script path will be <@verb{"xad:example:fact"}/>.
		  The following command will run this script.
	       </p>
	       <p>
		  <@verb{"run xad:example:fact"}/>
	       </p>
	    </section:numbered>
	    <section:numbered name="Script vs Function">
	       <p>
	       There are two ways to invoke a script <@icode{xxx}/>.
	       </p>
	       <list:unordered>
		  <list:item name="As a script">
		  Here the <@verb{"xxx.xact"}/> script is executed and its value is the result.
		  </list:item>
		  <list:item name="As a function">
		  Here <@verb{"xxx.xact"}/> must contain a visible function with name
		  <@icode{xxx}/>.
		  Execution then has two steps.
		  First, the script is executed and its result is discarded.
		  Second the function <@icode{xxx}/> is called and its value
		  is the result.
		  </list:item>
	       </list:unordered>
	       <p>
		  Execution as a function is the default.
		  If these is no function with name <@icode{xxx}/> then execution
		  as a script occurs.
	       </p>
	       <p>
		  The <ref:option name="scriptOnly"/> option will cause execution as a script
		  even when there is a function with name <@icode{xxx}/>.
		  The <ref:option name="funcOnly"/> option will cause execution as a function.
		  Execution will fail if there is no <@icode{xxx}/> function.
	       </p>
	       <p>
		  When running &xact; under a server as a CGI or servlet,
		  the <ref:option name="funcOnly"/> option is normally specified
		  for increased security.
	       </p>
	    </section:numbered>
	    <section:numbered name="Parameters">
	       <p>
	       When running a script function, it is possible to pass parameters
	       to that function. All parameters must have type <@icode{string}/>.
	       For example to pass <@icode{"abc"}/> and <@icode{"123"}/> to
	       script function <@icode{f}/> use the following command.
	       </p>
	       <p>
		  <@verb{"run f(abc,123)"}/>
	       </p>
	       <p>
		  Some string character must be escaped.
		  For example to pass <@icode{"a b"}/> and <@icode{"<&#123;>"}/> to
		  script function <@icode{f}/> use the following command.
	       </p>
	       <p>
		  <@verb{"run f(a+b,!(lt)!(=123)!(gt))"}/>
	       </p>
	    </section:numbered>
	    <section:numbered name="Passed">
	       <p>
		  In addition to parameters, there is another mechanism
		  for passing data to a script.
		  The @icode{passed}/> record contains named values passed
		  to the script.
		  Although <@icode{passed}/> was designed to enable HTML
		  form input to be passed to &xact; scripts, it
		  can be used for other purposes.
		  Consider the following command line.
	       </p>
	       <p>
		  <@verb{'run "foo(abc)&amp;a=true&amp;b=123"'}/>
	       </p>
	       This sets the <@icode{passed.a#rec}/> and <@icode{passed.b#rec}/> to
	       the specified string values.
	    </section:numbered>
	    <section:numbered name="Options">
	       <p>
		  The command line can also be used to set interpreter options.
		  The first command line argument specifies the script to be invoked, parameters,
		  and passed values. All later arguments specify interpreter options.
	       </p>
	       <p>
		  For boolean options, just listing its name as an option sets its value
		  to <@icode{"true"}/>.
	       </p>
	       <p>
		  An option of the form <@icode{ooo=vvv}/> sets option with name
		  name <@icode{ooo}/> to value <@icode{vvv}/>.
	       </p>
	       <p>
		  An example of options is shown here.
	       </p>
	       <p>
		  <@verb{'run bar funcOnly "errorMax=100"'}/>
	       </p>
	       <p>
		  A complete list of interpreter options can be found
		  in the Reference section of this document.
		  The <ref:example name="ShowOptions"/> example
		  prints out option values.
	       </p>
	    </section:numbered>
	    <section:numbered name="CGI">
	       <p>
		  Since &xact; scripts can easily generate HTML, it is natural
		  to run the &xact; interpreter from a web server.
		  The simplest way to do this is to run as a CGI.
		  The Windows file <@verb{"xact/dev/win/runc.bat"}/> (or
		  the Macintosh file <@verb{"xact/dev/mac/runc"}/>)is a sample command
		  for running &xact; as a CGI.
		  Copy this file to a CGI directory and edit the path to definitions.
	       </p>
	       <p>
		  Due to a bug in Apache 2 on Windows (loss of STDOUT from child programs), we know no way to
		  run &xact; under Apache on Windows. We recommend instead using the servlet version
		  of &xact; on Windows. This problem does not occur with Unix
		  versions of Apache 2 or with other Windows web servers.
	       </p>
	    </section:numbered>
	    <section:numbered name="Servlet">
	       <p>
		  Running as a CGI has the disadvantage that the Java JVM must
		  be started every time a script is run.
		  A faster alternative is to run the &xact; interpreter as
		  a servlet under a web server such as Apache Tomcat.
	       </p>
	       <p>
		  To run under Tomcat, you should copy two files into
		  the Tomcat <@verb{"webapps"}/> directory tree.
	       </p>
	       <list:unordered>
		  <list:item>
		     On Windows, copy &xact; file <@verb{"...\xact\dev\win\web.xml"}/> into
		     Tomcat file <@verb{"...\webapps\xact\WEB-INF\web.xml"}/>.
		     Next, you should edit this file to fix up file paths and optionally change
		     interpreter options.
		     Now, copy &xact; file <@verb{"...\xact\var\xact.jar"}/> into
		     Tomcat file <@verb{"...\webapps\xact\WEB-INF\lib\xact.jar"}/>.
		  </list:item>
		  <list:item>
		     On Macintosh, copy &xact; file <@verb{".../xact/dev/mac/web.xml"}/> into
		     Tomcat file <@verb{".../webapps/xact/WEB-INF/web.xml"}/>.
		     Next, you should edit this file to fix up file paths and optionally change
		     interpreter options.
		     Now, copy &xact; file <@verb{".../xact/var/xact.jar"}/> into
		     Tomcat file <@verb{".../webapps/xact/WEB-INF/lib/xact.jar"}/>.
		  </list:item>
	       </list:unordered>
	       <p>
		  Finally you should (re)start Tomcat.
	       </p>
	       <p>
		  A typical URL for testing the servlet interface is given here.
	       </p>
	       <p>
		  <@verb{"127.0.0.1:8080/xact/xs?main"}/>
	       </p>
	    </section:numbered>
	    <section:numbered name="Debugger">
	       <p>
		  The &xact; interpreter contains a early version of an &xact; debugger.
		  The debugger is incomplete and has many rough edges and bugs.
	       </p>
	       <p>
		  The debugger is entered when events specified by interpreter options
		  occur.
	       </p>
	       <list:unordered>
		  <list:item>  <ref:option name="debug"/>. Debug when the invoked script or function is about
		     to be executed.
		  </list:item>
		  <list:item> <ref:option name="debugAll"/>. Debug when any invoked or used script is about
		     to be executed.
		  </list:item>
		  <list:item> <ref:option name="debugError"/>. Debug when any error occurs.
		  </list:item>
		  <list:item>  <ref:option name="debugWarn"/>. Debug when any warning or error occurs.
		  </list:item>
	       </list:unordered>
	       <p>
		  There are two single-step control panels: 3x3 and 2x2.
		  The 3x3 columns are break before, break before or after, break after.
		  The 3x3 rows are break at higher level, break at current level, and
		  break at lower level.
		  The 2x2 panel includes <@verb{"S"}/> (restart), <@verb{"X"}/> (break
		  when running), <@verb{"=>"}/> (continue), <@verb{"<="}/> (rerun
		  expression), <@verb{"Q"}/> (quit).
	       </p>
	    </section:numbered>
	    <section:numbered name="Default Scripts">
	       <p>
		  There are two default scripts whose script paths
		  are specified in the <ref:option name="defaultScript"/> and <ref:option name="errorScript"/> options.
	       </p>
	       <p>
		  The default script is run if no script is specified.
		  This is done by specifying <@verb{'""'}/> on the command
		  line or no <@verb{"?"}/> and following query string
		  in a URL.
	       </p>
	       <p>
		  The error script is run after any script that has an error.
		  The supplied error script prints out the errors.
		  It is passes a parameter that is all output of the failing script
		  (except any that was already streamed out).
	       </p>
	    </section:numbered>
	 </section:numbered>
      </section:numbered>
   <section:top name="Reference">
      <include name="syntax"/>
      <section:lettered name="Syntax Summary">
	 <section:table name="BNF">
	    <table:table>
	       <table:titlerow>
		  <table:item>
		     Form
		  </table:item>
		  <table:item>
		     Meaning
		  </table:item>
	       </table:titlerow>
	       <table:row>
		  <table:item><ref:term1 name="tab"/></table:item>
		  <table:item>
		     The <verb>tab</verb> character
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:term name="ab"/></table:item>
		  <table:item>
		     The letter <verb>a</verb> followed by the letter <verb>b</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:term name="A"/><verb>..</verb><ref:term name="Z"/></table:item>
		  <table:item>
		     The characters <verb>A</verb> through <verb>Z</verb> inclusive
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="exp"/></table:item>
		  <table:item>
		     The non-terminal <verb>&lt;exp&gt;</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt1 name="text"/></table:item>
		  <table:item>
		     The non-terminal <verb>text</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item>
		     <verb>A B</verb>
		  </table:item>
		  <table:item>
		     <verb>A</verb> followed by <verb>B</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item>
		     <verb>A | B</verb>
		  </table:item>
		  <table:item>
		     Either <verb>A</verb> or <verb>B</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item>
		     <verb>A - B</verb>
		  </table:item>
		  <table:item>
		     Anything in <verb>A</verb> that is not also in <verb>B</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item>
		     <verb>{ A }?</verb>
		  </table:item>
		  <table:item>
		     Zero or one occurrences of <verb>A</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item>
		     <verb>{ A }+</verb>
		  </table:item>
		  <table:item>
		     One or more occurrences of <verb>A</verb>
		  </table:item>
	       </table:row>
	       <table:row>
		  <table:item>
		     <verb>{ A }*</verb>
		  </table:item>
		  <table:item>
		     Zero or more occurrences of <verb>A</verb>
		  </table:item>
	       </table:row>
	    </table:table>
	 </section:table>
	 <section:table name="Combined Syntax">
	    <syn:combined>
	       <include name="syntax"/>
	    </syn:combined>
	 </section:table>
	 <section:table name="Precedence">
	    <table:table>
	       <table:titlerow>
		  <table:item>Form</table:item>
		  <table:item>Op</table:item>
		  <table:item>Name</table:item>
		  <table:item>Precedence</table:item>
	       </table:titlerow>
	       <table:row>
		  <table:item><ref:nt name="prefix op"/></table:item>
		  <table:item><ref:preop name="~"/></table:item>
		  <table:item><ref:name name="Assert"/></table:item>
		  <table:item>1</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="="/></table:item>
		  <table:item><ref:name name="Equal"/></table:item>
		  <table:item>2</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name=":="/></table:item>
		  <table:item><ref:name name="Assign"/></table:item>
		  <table:item>3</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="|"/></table:item>
		  <table:item><ref:name name="Or"/></table:item>
		  <table:item>4</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="^"/></table:item>
		  <table:item><ref:name name="Xor"/></table:item>
		  <table:item>5</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="&amp;"/></table:item>
		  <table:item><ref:name name="And"/></table:item>
		  <table:item>6</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="=="/></table:item>
		  <table:item><ref:name name="Eq"/></table:item>
		  <table:item>7</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="!="/></table:item>
		  <table:item><ref:name name="Ne"/></table:item>
		  <table:item>7</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="&lt;"/></table:item>
		  <table:item><ref:name name="Less"/></table:item>
		  <table:item>8</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="&lt;="/></table:item>
		  <table:item><ref:name name="LessEq"/></table:item>
		  <table:item>8</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="&gt;"/></table:item>
		  <table:item><ref:name name="Greater"/></table:item>
		  <table:item>8</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="&gt;="/></table:item>
		  <table:item><ref:name name="GreaterEq"/></table:item>
		  <table:item>8</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name=".."/></table:item>
		  <table:item><ref:name name="Range"/></table:item>
		  <table:item>9</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="+"/></table:item>
		  <table:item><ref:name name="Add"/></table:item>
		  <table:item>10</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="-"/></table:item>
		  <table:item><ref:name name="Sub"/></table:item>
		  <table:item>10</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="*"/></table:item>
		  <table:item><ref:name name="Mult"/></table:item>
		  <table:item>11</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="/"/></table:item>
		  <table:item><ref:name name="Div"/></table:item>
		  <table:item>11</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="/+"/></table:item>
		  <table:item><ref:name name="Rem"/></table:item>
		  <table:item>11</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="++"/></table:item>
		  <table:item><ref:name name="Cat"/></table:item>
		  <table:item>12</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="prefix op"/></table:item>
		  <table:item><ref:preop name="-"/></table:item>
		  <table:item><ref:name name="Minus"/></table:item>
		  <table:item>13</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="prefix op"/></table:item>
		  <table:item><ref:preop name="!"/></table:item>
		  <table:item><ref:name name="Not"/></table:item>
		  <table:item>13</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="prefix op"/></table:item>
		  <table:item><ref:preop name="%"/></table:item>
		  <table:item><ref:name name="Percent"/></table:item>
		  <table:item>13</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="prefix op"/></table:item>
		  <table:item><ref:preop name="**"/></table:item>
		  <table:item><ref:name name="XDOMValue"/></table:item>
		  <table:item>13</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="~"/></table:item>
		  <table:item><ref:name name="Tilde"/></table:item>
		  <table:item>14</table:item>
	       </table:row>
	       <table:row>
		  <table:item><ref:nt name="infix op"/></table:item>
		  <table:item><ref:inop name="?"/></table:item>
		  <table:item><ref:name name="Question"/></table:item>
		  <table:item>14</table:item>
	       </table:row>
	    </table:table>
	 </section:table>
      </section:lettered>
      <section:lettered name="Tags" sort="true">
	 <section:tag name="x:block">
	    <part name="Description">
	       This command is used to introduce a new nested scope
	       or to group commands.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:block"/>
	       </syn:cmd>
	       <p>
		  No attributes or options are permitted.
	       </p>
	    </part>
	    <part name="Execution Semantics">
	       The result of executing a <ref:tag name="x:block"/> command
	       is the result of executing its body.
	    </part>
	    <part name="Examples">
	       <@code{@x:begin {
	          @x:const a := 3;
		  a + a
	       }}/>
	    </part>
	 </section:tag>
	 <section:tag name="x:break">
	    <part name="Description">
	       This command is used to end execution of
	       the smallest surrounding loop command.
	       Unlike the Java <@verb{"break"}/> statement, this command does not
	       immediately exit the loop. Instead, the loop is exited only
	       after completion of the current loop body execution.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:break"/>
	       </syn:cmd>
	       <p>
		  No attributes, options or body are permitted.
	       </p>
	    </part>
	    <part name="Execution Semantics">
	       The result of executing the <ref:tag name="x:break"/> command is <@icode{null}/>.
	       When the end of execution of the body of the smallest
	       surrounding <ref:tag name="x:for"/> or <ref:tag name="x:while"/> command
	       is reached, execution of that command is ended with no more body executions.
	    </part>
	    <part name="Examples">
	       <@code{
	          @x:var found := false;
	          @x:for i:=iter {
	             @x:if p(i) {
	                "found:"; i;
	                found := true;
	                @x:break;
		     } @x:else {
	                q(i)
		     }
		  }
	          @x:if ! found {
	             "not found"
	          }
	       }/>
	       <p>
		  Note that the <@icode{First}/> iterator can often be used to avoid the need for break.
		  For example the above example can be rewritten as
	       </p>
	       <@code{
	           @use library:iterator;
	           @x:for i := First[Filter[iter,p]] {
	              "found:"; i;
	           } @x:else {
	              "not found"
	           }
	       }/>
	    </part>
	 </section:tag>
	 <section:tag name="x:comment">
	    <part name="Description">
	       This command is used for program comments.
	       Comments are not discarded in the &xact; parser,
	       but instead are kept in the parse tree but have no effect on execution.
	    </part>
	    <part name="Command Syntax">
	       All attributes, options and body are ignored.
	    </part>
	    <part name="Execution Semantics">
	       The result of executing a <ref:tag name="x:comment"/> command
	       is <@icode{null}/>.
	    </part>
	    <part name="Examples">
	       <@code{
	          @x:comment "this is a comment";
	          // This is a sugared form of x:comment command
	          /* This is another 
	             sugared form of the x:comment command
	          */
	          @x:comment "heres how to comment out code" {
	             @x:if x == null {
	                x := y;
	             }
	          }
	       }/>
	    </part>
	 </section:tag>
	 <section:tag name="x:const">
	    <part name="Description">
	       This command declares a named constant.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:const"/>
		  <ref:nt name="id"/>
		  <syn:opt>
		     <ref:inop name="~"/>
		     <ref:nt name="exp"/>
		  </syn:opt>
		  <ref:inop name=":="/>
		  <ref:nt name="exp"/>
	       </syn:cmd>
	       <p>
		  No body is permitted.
	       </p>
	       <p>
		  The following options are permitted.
	       </p>
	       <table:table>
		  <table:row>
		     <table:item><ref:option name="visible"/></table:item>
		     <table:item>
		     The constant name is declared as visible in the enclosing scope.
		     If <ref:option name="visible"/> is specified,
		     then <ref:option name="local"/> can not be specified.
		     </table:item>
		  </table:row>
		  <table:row>
		     <table:item><ref:option name="local"/></table:item>
		     <table:item>
			The constant name is declared as local in the enclosing scope.
			If <ref:option name="local"/> is specified,
			then <ref:option name="visible"/> can not be specified.
		     </table:item>
		  </table:row>
	       </table:table>
	    </part>
	    <part name="Name Semantics">
	       The <ref:nt name="id"/> constant name is declared the scope that surrounds the
	       <ref:tag name="x:const"/> command.
	    </part>
	    <part name="Execution Semantics">
	       The constant is initialized to the value of the initial value expression
	       following the <@verb{":="}/>.
	       The value must satisfy the type or view given following any <@verb{"~"}/>.
	       The result of executing the <ref:tag name="x:const"/> command is <@icode{null}/>.
	    </part>
	    <part name="Examples">
	       <@code{
	          @x:const a~int := 5;
	       }/>
	    </part>
	 </section:tag>
	 <section:tag name="x:else">
	    <part name="Description">
	       This command work with an immediately preceding if, orif or for command.
	       ITs body is executed only if the body of the previous command was not executed.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:else"/>
	       </syn:cmd>
	       <p>
		  No attributes, options or body are permitted.
	       </p>
	       <p>
		  A <ref:tag name="x:else"/> command must directly follow
		  a <@ref:tag name="x:if"/>, <ref:tag name="x:orif"/> or <ref:tag name="x:for"/> command.
	       </p>
	    </part>
	    <part name="Execution Semantics">
	       If the body of the previous command was executed,
	       then the result of executing the <ref:tag name="x:else"/> command is <@icode{null}/>.
	       If the body of the previous command was not executed,
	       then the result of the <ref:tag name="x:else"/> command
	       is the result of executing its body.
	    </part>
	    <part name="Examples">
	       <@code{
	       @x:if i < j {
	          "less"
	       } @x:orif i > j {
	          "greater"
	       } @x:else {
	          "equal"
	       }
	       }/>
	       <@code{
	           @use library:iterator;
	           @x:for i := First[Filter[iter,p]] {
	              "found:"; i;
	           } @x:else {
	              "not found"
	           }
	       }/>
	    </part>
	 </section:tag>
	 <section:tag name="x:exclude">
	    <part name="Description">
	       This command is used for mutual exclusion and monitors based
	       on a <@icode{lock}/>.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:exclude"/>
		  <ref:nt name="exp"/>
	       </syn:cmd>
	    <p>
	       No options are permitted.
	    </p>
	    </part>
	    <part name="Execution Semantics">
	       The expression is evaluated and the result must have type <@icode{lock}/>.
	       If the lock is locked, execution of the current thread waits
	       until the lock is unlocked.
	       If the lock is unlocked, then it is locked and the body is executed.
	       After the end of body execution the lock is unlocked.
	       Calling <@icode{lock}/> operations within the body
	       can be used to make the <ref:tag name="x:exclude"/> command operate as 
	       a monitor.
	    </part>
	    <part name="Examples">
	       <@code{
	       @x:type counter;
	       @x:self {
	          @x:var val := 0;
		  @x:var lock1 := lock;
		  @x:func incr(),visible {
		     @x:exclude lock1 {
		        val := val + 1;
		     }
		  }
		  @x:func decr(),visible {
		     @x:exclude lock1 {
		        val := val - 1;
		     }
		  }
	       }
	       }/>
	       <p>
		  The <ref:example name="queue"/> example shows the use of monitors.
	       </p>
	    </part>
	 </section:tag>
	 <section:tag name="x:exp">
	    <part name="Description">
	       The result of this command is the result of its single expression.          
	       It is useful when embedding expressions into XML syntax.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:exp"/>
		  <ref:nt name="exp"/>
	       </syn:cmd>
	    <p>
	       No options or body are permitted.
	    </p>
	    </part>
	    <part name="Execution Semantics">
	       The result of executing the <ref:tag name="x:exp"/> command is
	       the result of executing it attribute expression.
	    </part>
	    <part name="Examples">
	       <@icode{
	       <b>
		  The sum of &a; and &b; is <@x:exp a+b/>.
	       </b>
	       }/>
	    </part>
	 </section:tag>
	 <section:tag name="x:for">
	    <part name="Description">
	       This command repeatedly execute its body under the control of an iterator.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:for"/>
		  <ref:nt name="for ids"/>
		  <ref:inop name=":="/>
		  <ref:nt name="exp"/>
	       </syn:cmd>
	       <syn:cmdprods>
		  <ref:nt name="for ids"/>
		  <syn:prod>
		     <ref:nt name="id"/>
		  </syn:prod>
		  <syn:prod>
		     <ref:term name="["/>
		     <syn:star>
			<ref:nt name="id"/>
			<ref:term name=","/>
		     </syn:star>
		     <ref:nt name="id"/>
		     <ref:term name="]"/>
		  </syn:prod>
	       </syn:cmdprods>
	       <p>
		  No options are permitted.
	       </p>
	    </part>
	       <part name="Name Semantics">
		  The for <ref:nt name="id"/>'s are declared the scope that surrounds the
		  <ref:tag name="x:for"/> command.
	    </part>
	    <part name="Execution Semantics">
	       <p>
	       A for command of the form
	       <@code{@x:for i:=iter  { b(i) } }/>
	       is equivalent to
	       <@code{
		@x:block{
	            @x:func sys:Body(i){b(i)}
	            iter(sys:Body);
	       }}/>
	       </p>
	       <p>
	       A for command of the form
	       <@code{@x:for [i,j]:=iter  { c(i,j) } }/>
	       is equivalent to
	       <@code{
		@x:block{
	            @x:func sys:Body(i,j){c(i,j)}
	            iter(sys:Body);
	       }}/>
	       </p>
	       </part>
	    <part name="Examples">
	       <@code{
	       @x:for i:=1..10 {
	          i; "=>"; f(i);
	       }
	       }/>
	       <@code{
	       @use library:iterator;
	       @x:for [i,j]:= Nest[1..3,1..2] {
	       "<&i;,&j;>&eol;"
	       }
	       }/>
	       <@code{
	           @use library:iterator;
	           @x:for i := First[Filter[iter,p]] {
	              "found:"; i;
	           } @x:else {
	              "not found"
	           }
	       }/>
	    </part>
	 </section:tag>
	 <section:tag name="x:fork">
	    <part name="Description">
	       This command encloses a set of <ref:tag name="x:thread"/> commands
	       to provide multi-thread fork/join semantics.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:fork"/>
	       </syn:cmd>
	       <p>
		  No attributes, options or body are permitted.
	       </p>
	    </part>
	    <part name="Execution Semantics">
	       <p>
		  The result of executing a <ref:tag name="x:thread"/> command
		  is the result of executing its body.
	       </p>
	       <p>
		  After the body execution completes, the current thread waits until
		  all threads created by immediately enclosed <ref:tag name="x:thread"/> commands
		  finish executing.
	       </p>
	    </part>
	    <part name="Examples">
	       <@code{
	          @x:fork {
	             @x:thread t1 { subtask1() }
	             @x:thread t2 { subtask2() }
	             maintask();
	          }
	       }/>
	       <p>
		  See <ref:example name="IncrParse"/> example and <ref:example name="queue"/> example.
	       </p>
	    </part>
	 </section:tag>
	 <section:tag name="x:func">
	    <part name="Description">
	       This command declares a function.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:func"/>
		  <ref:nt name="id"/>
		  <syn:opt>
		     <ref:term name="["/>
		     <ref:nt name="func formals"/>
		     <ref:term name="]"/>
		  </syn:opt>
		  <syn:opt>
		     <ref:term name="("/>
		     <ref:nt name="func formals"/>
		     <ref:term name=")"/>
		  </syn:opt>
		  <syn:opt>
		     <ref:preop name="~"/>
		     <ref:nt name="exp"/>
		  </syn:opt>
	       </syn:cmd>
	       <syn:cmdprods>
		  <ref:nt name="func formals"/>
		  <syn:prod>
		  </syn:prod>
		  <syn:prod>
		     <ref:preop name="%"/>
		     <ref:nt name="id"/>
		  </syn:prod>
		  <syn:prod>
		     <syn:star>
			<ref:nt name="func formal"/>
			<ref:term name=","/>
		     </syn:star>
		     <ref:nt name="func formal"/>
		  </syn:prod>
	       </syn:cmdprods>
	       <syn:cmdprods>
		  <ref:nt name="func formal"/>
		  <syn:prod>
		     <ref:nt name="id"/>
		     <syn:opt>
			<ref:inop name="~"/>
			<ref:nt name="exp"/>
		     </syn:opt>
		  </syn:prod>
	       </syn:cmdprods>
	       <p>
		  The following options are permitted.
	       </p>
	       <table:table>
		  <table:row>
		     <table:item><ref:option name="lhs"/></table:item>
		     <table:item>
			This function is a left-hand-side function that can be called
			from the left-hand-side of assignments.
			There must also be a <ref:option name="rhs"/> function
			with the same name declared in the same scope.
			Only one of <ref:option name="lhs"/> and <ref:option name="rhs"/> can
			be specified on a single function.
		     </table:item>
		  </table:row>
		  <table:row>
		     <table:item><ref:option name="rhs"/></table:item>
		     <table:item>
			This function is a left-hand-side function that can be called
			from the left-hand-side of assignments.
			There must also be a <ref:option name="rhs"/> function
			with the same name declared in the same scope.
			Only one of <ref:option name="lhs"/> and <ref:option name="rhs"/> can
			be specified on a single function.
		     </table:item>
		  </table:row>
		  <table:row>
		     <table:item><ref:option name="visible"/></table:item>
		     <table:item>
		     The function name is declared as visible in the enclosing scope.
		     If <ref:option name="visible"/> is specified,
		     then <ref:option name="local"/> can not be specified.
		     For lhs-rhs function pairs either both or neither must
		     be <ref:option name="visible"/>.
		     </table:item>
		  </table:row>
		  <table:row>
		     <table:item><ref:option name="local"/></table:item>
		     <table:item>
			The function name is declared as local in the enclosing scope.
			If <ref:option name="local"/> is specified,
			then <ref:option name="visible"/> can not be specified.
			For lhs-rhs function pairs either both or neither must
			be <ref:option name="local"/>.
			The <ref:option name="local"/> option is only used for names
			declared directly within <ref:tag name="x:type"/>, <ref:tag name="x:view"/> and <ref:tag name="x:view"/> commands.
		     </table:item>
		  </table:row>
	       </table:table>
	    </part>
	    <part name="Name Semantics">
	       The func name is declared the scope that surrounds the <ref:tag name="x:func"/> command.
	       The func formal <ref:nt name="id"/>s are declared within the <ref:tag name="x:func"/> command scope.
	    </part>
	    <part name="Execution Semantics">
	       <p>
		  Execution of the <ref:tag name="x:func"/> command
		  associates the function value with the instance of the function name.
		  The result of execution of the <ref:tag name="x:func"/> command is <@icode{null}/>.
		  The body of the function is executed only when the function is called.
		  A function can no longer be called after the scope containing the function command exits.
	       </p>
	    </part>
	    <part name="Examples">
	       <@code{
	       @x:func fact(n) {
	          @x:if n == 0 {
	             1
	          } @x:else {
	             n * fact(n - 1)
	          }
	       }
	       @x:for i := 1..10 {
	          @x:const j := fact(i);
	          "fact(&i;)=&j;&eol;"
	       }
	       }/>
	       <@code{
	          @x:func sum[t](a~t,b~t)~t {
	             a+b
	          }
		  sum[int](2,3);
	          sum[float](2.3,7.99);
	       }/>
	       <p>
		  See <ref:example name="curry"/> example.
	       </p>
	    </part>
	 </section:tag>
	 <section:tag name="x:if">
	    <part name="Description">
	       This command executes its body only if a test expression is true.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:if"/>
		  <ref:nt name="exp"/>
	       </syn:cmd>
	    <p>
	       No options are permitted.
	    </p>
	    </part>
	    <part name="Execution Semantics">
	       The attribute expression is evaluated and must yield a <@icode{boolean}/> result.
	       If the result is <@icode{true}/>, then the result of executing 
	       the <ref:tag name="x:if"/> command is the result of the executing its body.
	       If the result is <@icode{false}/>, then the body is not executed and
	       the result of the <ref:tag name="x:if"/> command is <@icode{null}/>.
	    </part>
	    <part name="Examples">
	       <@code{
	       @x:if i < j {
	          "less"
	       } @x:orif i > j {
	          "greater"
	       } @x:else {
	          "equal"
	       }
	       }/>
	    </part>
	 </section:tag>
	 <section:tag name="x:lang">
	    <part name="Description">
	       This command changes the language used
	       to interpret following commands.
	       It specifies a language object for the new language.
	       For more information see the <ref:numbered name="Language Definition"/> section.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:lang"/>
		  <ref:nt name="id"/>
		  <ref:term name=","/>
		  <ref:nt name="id"/>
	       </syn:cmd>
	    </part>
	    <part name="Semantics">
		  The first attribute <ref:nt name="id"/> will be a <ref:gloss name="script path"/> that identifies an external script.
		  The second attribute <ref:nt name="id"/> will be a visible name of that script.
		  Evaluation of that name must yield a language object that will be used
		  to interpret all code after the <ref:tag name="x:lang"/> command through the
		  end of the smallest enclosing scope.
	    </part>
	 </section:tag>
	 <section:tag name="x:module">
	    <part name="Description">
	       This command is used to control name visibility.
	    </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:module"/>
		  <syn:opt>
		     <ref:nt name="module specs"/>
		  </syn:opt>
	       </syn:cmd>
	       <syn:cmdprods>
		  <ref:nt name="module specs"/>
		  <syn:seq>
		     <syn:star>
			<ref:nt name="module spec"/>
			<ref:term name=","/>
		     </syn:star>
		     <ref:nt name="module spec"/>
		  </syn:seq>
	       </syn:cmdprods>
	       <syn:cmdprods>
		  <ref:nt name="module spec"/>
		  <syn:prod>
			<ref:term name="visible"/>
		  </syn:prod>
		  <syn:prod>
			<ref:term name="hidden"/>
		  </syn:prod>
		  <syn:prod>
			<ref:term name="visible"/>
			   <ref:term name="("/>
			      <syn:star>
				 <ref:nt name="module item"/>
				 <ref:term name=","/>
			      </syn:star>
				 <ref:nt name="module item"/>
			   <ref:term name=")"/>
		  </syn:prod>
		  <syn:prod>
			<ref:term name="hidden"/>
			   <ref:term name="("/>
			      <syn:star>
				 <ref:nt name="module item"/>
				 <ref:term name=","/>
			      </syn:star>
				 <ref:nt name="module item"/>
			   <ref:term name=")"/>
		  </syn:prod>
		  <p>
		     No options are permitted.
		  </p>
	       </syn:cmdprods>
	       <syn:cmdprods>
		  <ref:nt name="module item"/>
		  <syn:prod>
		     <ref:nt name="id"/>
		     <syn:opt>
			<ref:term name="["/>
			<ref:term name="]"/>
		     </syn:opt>
		  </syn:prod>
		  <syn:prod>
		     <ref:nt name="id"/>
		     <syn:opt>
			<ref:term name="["/>
			<ref:term name="]"/>
		     </syn:opt>
		     <ref:inop name="&gt;"/>
		     <ref:nt name="id"/>
		  </syn:prod>
	       </syn:cmdprods>
	       <p>
		  At most one of <@icode{hidden}/> or <@icode{visible}/> (without any
		  following list may be specified.
		  No name may appear in both <@icode{hidden}/> <@icode{visible}/> name lists.
		  Every name that appears within a name list must be defined
		  within the <ref:tag name="x:module"/> command as visible.
	       </p>
	    </part>
	    <part name="Name Semantics">
	       <p>
	       Select visible names declared within the <ref:tag name="x:module"/> scope that
	       are visible are also declared within the scope that immediately
	       contains the <ref:tag name="x:module"/> command.
	       </p>
	       <p>
		  There are several cases for each name that is visible within the module.
		  <list:unordered>
		     <list:item>
			If there are no name lists and <@icode{visible}/>
			was specified, then the name is declared as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			If there are no name lists and <@icode{visible}/>
			was not specified, then the name is declared but not as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			If the name was specified in the <@icode{visible}/> name list,
			then the name is declared as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			If the name was specified in the <@icode{hidden}/> name list,
			then the name is declared but not as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			Names lists are present and the name does not appear in any
			name list and <@icode{visible}/> (with no list) was specified,
			then the name is declared as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			Names lists are present and the name does not appear in any
			name list and <@icode{hidden}/> (with no list) was specified,
			then the name is declared as but not as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			Names lists are present and the name does not appear in any
			name list and <@icode{hidden}/> (with no list) was not specified
			and <@icode{visible}/> (with no list) was not specified,
			then the name is not declared within the enclosing scope.
		     </list:item>
		  </list:unordered>
	       </p>
	       <p>
		  The name list forms also provide renaming.
		  The name with the <ref:nt name="id"/> specified before the
		  <@verb{">"}/> declared within the module
		  is declared with the <ref:nt name="id"/> specified after
		  the <@verb{">"}/> in the enclosing scope.
	       </p>
	    </part>
	    <part name="Execution Semantics">
	       Execution of a <ref:tag name="x:module"/> command
	       results in execution of its body.
	       The result of that execution is discarded.
	       The body scope instance is not discarded
	       until the end of the enclosing scope instance.
	       The result of executing a <ref:tag name="x:module"/> command
	       is <@icode{null}/>.
	    </part>
	    <part name="Examples">
	       <@code{
	          @module {
	              @x:var v := 0;
	              @x:func incr(), visible { v := v + 1 }
	              @x:func val(),visible { v }
	          }
	          // can't see v here
	          incr(); incr();
	          val();
	       }/>
	    </part>
	 </section:tag>
	       <section:tag name="x:orif">
		  <part name="Description">
		     This command combines the effect of an <ref:tag name="x:else"/> command
		     with a <ref:tag name="x:if"/> command.
		  </part>
		  <part name="Command Syntax">
		     <syn:cmd>
			<ref:term name="@x:orif"/>
			<ref:nt name="exp"/>
		     </syn:cmd>
		  </part>
	       <p>
		  No options or body are permitted.
	       </p>
	       <p>
		  A <ref:tag name="x:orif"/> command must directly follow
		  a <ref:tag name="x:if"/> or <ref:tag name="x:orif"/> command.
	       </p>
	       <part name="Execution Semantics">
	       If the body of the previous command was executed,
	       then the result of executing the <ref:tag name="x:orif"/> command is <@icode{null}/>.
	       Otherwise, the attribute expression is evaluated and must yield a <@icode{boolean}/> result.
	       If the result is <@icode{true}/>, then the result of executing 
	       the <ref:tag name="x:orif"/> command is the result of the executing its body.
	       If the result is <@icode{false}/>, then the body is not executed and
	       the result of the <ref:tag name="x:orif"/> command is <@icode{null}/>.
	       </part>
	       <part name="Examples">
	       <@code{
	       @x:if i < j {
	          "less"
	       } @x:orif i > j {
	          "greater"
	       } @x:else {
	          "equal"
	       }
	       }/>
	       </part>
	       </section:tag>
	       <section:tag name="x:self">
		  <part name="Description">
		     This command provides instance specific operations and data
		     for the preceding <ref:tag name="x:type"/> or <ref:tag name="x:view"/> command/
		  </part>
		  <part name="Command Syntax">
		     <syn:cmd>
			<ref:term name="@x:self"/>
		     </syn:cmd>
		     <p>
			No attributes or options are permitted.
		     </p>
		     <p>
			A <ref:tag name="x:self"/> command must directly follow
			a <ref:tag name="x:type"/> or <ref:tag name="x:view"/> command.
		  </p>
		  </part>
	    <part name="Execution Semantics">
	       <p>
		  For types, instances of the self command are created for each object
		  constructed for that type.
	       </p>
	       <p>
		  For views, an instance of the self command is created on demand for each object to which the
		  view was applied.
	       </p>
	       <p>
		  The body of the self command is executed for each self instance when
		  it is created. The result of that execution is discarded.
	       </p>
	    </part>
	    <part name="Examples">
	       See <ref:example name="stack"/> example and <ref:example name="unit"/> example.
	    </part>
	       </section:tag>
	       <section:tag name="x:tag">
		  <part name="Description">
		     This command returns a rendering of a specified <@icode{xdom:element}/> tree node.
		  </part>
		  <part name="Command Syntax">
		     <syn:cmd>
			<ref:term name="@x:tag"/>
			<ref:nt name="exp"/>
		     </syn:cmd>
		  <p>
		     No options are permitted.
		  </p>
		  </part>
		  <part name="Execution Semantics">
		     The attribute expression is evaluated and must yield
		     a  <@icode{TypeOr[xdom:element,void]}/> value
		     and the body is executed and must yield a <@icode{string}/>.
		     If the attribute value is <@icode{null}/> then the result
		     of the <ref:tag name="x:tag"/> command is the value of its body.
		     Otherwise, the result of executing a <ref:tag name="x:tag"/> command will be a <@icode{string}/> that 
		     is a rendering of the attribute element.
		     Any body of the element is ignored, and the result of the tag command body
		     will be the body of the resulting string rendering.
		  </part>
		  <part name="Examples">
		     <@code{
		        @x:tag xdom:element("a",attr=rec(href="http://www.cnn.com"),kind="xml") {
		           "News"
			}
		     }/>
		  </part>
	       </section:tag>
	       <section:tag name="x:thread">
		  <part name="Description">
		     This command  must be directly within an
		     enclosing <ref:tag name="x:fork"/> command.
		     It creates a new thread.
		  </part>
		  <part name="Command Syntax">
		     <syn:cmd>
			<ref:term name="@x:thread"/>
			<ref:nt name="id"/>
		     </syn:cmd>
		     <p>
			No options are permitted.
		     </p>
		     <p>
			Each <ref:tag name="x:thread"/> command must appear immediately within
			a <ref:tag name="x:fork"/> command.
		     </p>
		  </part>
		  <part name="Name Semantics">
		     The <ref:nt name="id"/> thread name is declared the scope that surrounds the
		     <ref:tag name="x:thread"/> command.
	    </part>
	    <part name="Execution Semantics">
	       A new thread is created and the body is executed within that new thread.
	       The result of that execution is discarded.
	       Meanwhile the main thread continues executing after the <ref:tag name="x:thread"/> command.
	       The result of executing the <ref:tag name="x:thread"/> command is <@icode{null}/>.
	    </part>
	    <part name="Examples">
	       <@code{
	          @x:fork {
	             @x:thread t1 { subtask1() }
	             @x:thread t2 { subtask2() }
	             maintask();
	          }
	       }/>
	       <p>
		  See <ref:example name="IncrParse"/> example and <ref:example name="queue"/> example.
	       </p>
	    </part>
	       </section:tag>
	       <section:tag name="x:type">
		  <part name="Description">
		     This command declares a type.
		     It must be followed with a <ref:tag name="x:self"/> command.
		  </part>
		  <part name="Command Syntax">
		     <syn:cmd>
			<ref:term name="@x:type"/>
			<ref:nt name="id"/>
			<syn:opt>
			   <ref:term name="["/>
			   <ref:nt name="type formals"/>
			   <ref:term name="]"/>
			</syn:opt>
		     </syn:cmd>
		     <syn:cmdprods>
			<ref:nt name="type formals"/>
			<syn:prod>
			</syn:prod>
			<syn:prod>
			   <ref:preop name="%"/>
			   <ref:nt name="id"/>
			</syn:prod>
			<syn:prod>
			   <syn:star>
			      <ref:nt name="type formal"/>
			      <ref:term name=","/>
			   </syn:star>
			   <ref:nt name="type formal"/>
			</syn:prod>
		     </syn:cmdprods>
		     <syn:cmdprods>
			<ref:nt name="type formal"/>
			<syn:prod>
			   <ref:nt name="id"/>
			   <syn:opt>
			      <ref:inop name="~"/>
			      <ref:nt name="exp"/>
			   </syn:opt>
			</syn:prod>
		     </syn:cmdprods>
	       <p>
		  The following options are permitted.
	       </p>
	       <table:table>
		  <table:row>
		     <table:item><ref:option name="visible"/></table:item>
		     <table:item>
		     The type name is declared as visible in the enclosing scope.
		     If <ref:option name="visible"/> is specified,
		     then <ref:option name="local"/> can not be specified.
		     </table:item>
		  </table:row>
		  <table:row>
		     <table:item><ref:option name="local"/></table:item>
		     <table:item>
			The type name is declared as local in the enclosing scope.
			If <ref:option name="local"/> is specified,
			then <ref:option name="visible"/> can not be specified.
		     </table:item>
		  </table:row>
	       </table:table>
		  </part>
		  <part name="Name Semantics">
		     The type name is declared in
		     the scope that surrounds the
		     <ref:tag name="x:type"/> command.
		     If the type name has a name extension, then that name without an extension
		     is declared in
		     the scope that surrounds the
		     <ref:tag name="x:type"/> command as a view that matches any instance of the type.
		     The type formal <ref:nt name="id"/>s are declared within the
		     <ref:tag name="x:type"/> command scope.
		  </part>
	    <part name="Execution Semantics">
	       <p>
		  Execution of the <ref:tag name="x:type"/> command
		  associates the type value with the instance of the type name.
		  The result of execution of the <ref:tag name="x:type"/> command is <@icode{null}/>.
	       </p>
	       <p>
		  Instances of the type declaration are created for each specific type referenced.
		  If the type name has no extension there will be only one instance.
		  If the type name has an extension, then there will be a different instance
		  for each different name extension value list.
		  Instances are created on demand as needed and exist until
		  the scope containing the type command exits.
		  The body of the type command is executed for each type instance when
		  it is created. The result of that execution is discarded.
	       </p>
	    </part>
	    <part name="Examples">
	       See <ref:example name="stack"/> example and <ref:example name="unit"/> example.
	    </part>
	       </section:tag>
	       <section:tag name="x:use">
		  <part name="Description">
		     This command is used to reference names from an external
		     script.
		  </part>
	    <part name="Command Syntax">
	       <syn:cmd>
		  <ref:term name="@x:use"/>
                  <syn:seq>
                     <ref:nt name="id"/>
                     <syn:opt>
                        <ref:nt name="use specs"/>
                     </syn:opt>
                  </syn:seq>
	       </syn:cmd>
	       <syn:cmdprods>
		  <ref:nt name="use specs"/>
		  <syn:seq>
		     <syn:star>
			<ref:nt name="use spec"/>
			<ref:term name=","/>
		     </syn:star>
		     <ref:nt name="use spec"/>
		  </syn:seq>
	       </syn:cmdprods>
	       <syn:cmdprods>
		  <ref:nt name="use spec"/>
		  <syn:prod>
		     <ref:term name="visible"/>
		  </syn:prod>
		  <syn:prod>
		     <ref:term name="hidden"/>
		  </syn:prod>
		  <syn:prod>
		     <ref:term name="visible"/>
		     <ref:term name="("/>
		     <syn:star>
			<ref:nt name="use item"/>
			<ref:term name=","/>
		     </syn:star>
		     <ref:nt name="use item"/>
		     <ref:term name=")"/>
		  </syn:prod>
		  <syn:prod>
		     <ref:term name="hidden"/>
		     <ref:term name="("/>
		     <syn:star>
			<ref:nt name="use item"/>
			<ref:term name=","/>
		     </syn:star>
		     <ref:nt name="use item"/>
		     <ref:term name=")"/>
		  </syn:prod>
	       </syn:cmdprods>
	       <syn:cmdprods>
		 <ref:nt name="use item"/>
		  <syn:prod>
		     <ref:nt name="id"/>
		     <syn:opt>
			<ref:term name="["/>
			<ref:term name="]"/>
		     </syn:opt>
		  </syn:prod>
		  <syn:prod>
		     <ref:nt name="id"/>
		     <syn:opt>
			<ref:term name="["/>
			<ref:term name="]"/>
		     </syn:opt>
		     <ref:inop name="&gt;"/>
		     <ref:nt name="id"/>
		  </syn:prod>
	       </syn:cmdprods>
		  <p>
		     No options or body are permitted.
		  </p>
	    </part>
	    <part name="Name Semantics">
	       <p>
	       Select visible names declared within the top-level scope of the used script that
	       are visible are also declared within the scope that immediately
	       contains the <ref:tag name="x:use"/> command.
	       </p>
	       <p>
		  There are several cases for each name that is visible within the used script.
		  <list:unordered>
		     <list:item>
			If there are no name lists and <@icode{visible}/>
			was specified, then the name is declared as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			If there are no name lists and <@icode{visible}/>
			was not specified, then the name is declared but not as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			If the name was specified in the <@icode{visible}/> name list,
			then the name is declared as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			If the name was specified in the <@icode{hidden}/> name list,
			then the name is declared but not as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			Names lists are present and the name does not appear in any
			name list and <@icode{visible}/> (with no list) was specified,
			then the name is declared as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			Names lists are present and the name does not appear in any
			name list and <@icode{hidden}/> (with no list) was specified,
			then the name is declared as but not as <@icode{visible}/> in
			the enclosing scope.
		     </list:item>
		     <list:item>
			Names lists are present and the name does not appear in any
			name list and <@icode{hidden}/> (with no list) was not specified
			and <@icode{visible}/> (with no list) was not specified,
			then the name is not declared within the enclosing scope.
		     </list:item>
		  </list:unordered>
	       </p>
	       <p>
		  The name list forms also provide renaming.
		  The name with the <ref:nt name="id"/> specified before the
		  <@verb{">"}/> declared within the used script
		  is declared with the <ref:nt name="id"/> specified after
		  the <@verb{">"}/> in the enclosing scope.
	       </p>
	    </part>
	    <part name="Execution Semantics">
	       <p>
		  The first attribute <ref:nt name="id"/> will be a <ref:gloss name="script path"/> that identifies an external script.
		  A script path consist consist of a sequence of ids separated with <@verb{":"}/>'s.
		  Initial ids specify a path through nested script directories and the final
		  id will be the id for the script.
	       </p>
	       <p>
		  No script can directly or indirectly use itself.
	       </p>
	       <p>
		  Before a script is executed, all other scripts that is uses
		  will have been executed, their results discarded, and
		  their script instances retained.
	       </p>
	       <p>
		  If another script uses another script either directly or indirectly,
		  then only one instance of that second script will be created.
	       </p>
	       <p>
	       </p>
	    </part>
	    <part name="Examples">
	       <@code{
	          @x:use library:unparser;
	          @x:use library:iterator,hidden(Nest > MyNest);
	       }/>
	    </part>
	    </section:tag>
	    <section:tag name="x:var">
	       <part name="Description">
		  This command declares a named constant.
	       </part>
	       <part name="Command Syntax">
		  <syn:cmd>
		     <ref:term name="@x:var"/>
		     <ref:nt name="id"/>
		     <syn:opt>
			<ref:inop name="~"/>
			<ref:nt name="exp"/>
		     </syn:opt>
		     <syn:opt>
			<ref:inop name=":="/>
			<ref:nt name="exp"/>
		     </syn:opt>
		  </syn:cmd>
		  <p>
		     No body is permitted.
		  </p>
	       <p>
		  The following options are permitted.
	       </p>
	       <table:table>
		  <table:row>
		     <table:item><ref:option name="visible"/></table:item>
		     <table:item>
		     The variable name is declared as visible in the enclosing scope.
		     If <ref:option name="visible"/> is specified,
		     then <ref:option name="local"/> can not be specified.
		     </table:item>
		  </table:row>
		  <table:row>
		     <table:item><ref:option name="local"/></table:item>
		     <table:item>
			The variable name is declared as local in the enclosing scope.
			If <ref:option name="local"/> is specified,
			then <ref:option name="visible"/> can not be specified.
		     </table:item>
		  </table:row>
	       </table:table>
	       </part>
	       <part name="Name Semantics">
	       The <ref:nt name="id"/> variable name is declared the scope that surrounds the
		  <ref:tag name="x:var"/> command.
	       </part>
	    <part name="Execution Semantics">
		  The variable is initialized to the value of the initial value expression
		  following the <@verb{":="}/>.
		  If no initial value is specified, then the variable is uninitialized.
		  Attempting to use an uninitialized variable will result in
		  an execution error.
		  The initial value, if specified, and any later value assigned
		  to the variable must satisfy the type or view given following any <@verb{"~"}/>.
		  The result of executing the <ref:tag name="x:var"/> command is <@icode{null}/>.
	    </part>
	    <part name="Examples">
	       <@code{
	          @x:var a~int := 5;
	       }/>
	    </part>
	    </section:tag>
		     <section:tag name="x:view">
			<part name="Description">
			   This command declares a view.
			</part>
			<part name="Command Syntax">
			   <syn:cmd>
			      <ref:term name="@x:view"/>
			      <ref:nt name="id"/>
			      <syn:opt>
				 <ref:term name="["/>
				 <ref:nt name="view formals"/>
				 <ref:term name="]"/>
			      </syn:opt>
			   </syn:cmd>
			   <syn:cmdprods>
			      <ref:nt name="view formals"/>
			      <syn:prod>
			      </syn:prod>
			      <syn:prod>
				 <ref:preop name="%"/>
				 <ref:nt name="id"/>
			      </syn:prod>
			      <syn:prod>
				 <syn:star>
				    <ref:nt name="view formal"/>
				    <ref:term name=","/>
				 </syn:star>
				 <ref:nt name="view formal"/>
			      </syn:prod>
			   </syn:cmdprods>
			   <syn:cmdprods>
			      <ref:nt name="view formal"/>
			      <syn:prod>
				 <ref:nt name="id"/>
				 <syn:opt>
				    <ref:inop name="~"/>
				    <ref:nt name="exp"/>
				 </syn:opt>
			      </syn:prod>
			   </syn:cmdprods>
	       <p>
		  The following options are permitted.
	       </p>
	       <table:table>
		  <table:row>
		     <table:item><ref:option name="visible"/></table:item>
		     <table:item>
		     The view name is declared as visible in the enclosing scope.
		     If <ref:option name="visible"/> is specified,
		     then <ref:option name="local"/> can not be specified.
		     </table:item>
		  </table:row>
		  <table:row>
		     <table:item><ref:option name="local"/></table:item>
		     <table:item>
			The view name is declared as local in the enclosing scope.
			If <ref:option name="local"/> is specified,
			then <ref:option name="visible"/> can not be specified.
		     </table:item>
		  </table:row>
	       </table:table>
			</part>
			<part name="Name Semantics">
			   The view name is declared the scope that surrounds the
			   <ref:tag name="x:view"/> command.
			   The view formal <ref:nt name="id"/>s are declared within the
			   <ref:tag name="x:view"/> command scope.
			</part>
	    <part name="Execution Semantics">
	       <p>
		  Execution of the <ref:tag name="x:view"/> command
		  associates the view value with the instance of the view name.
		  The result of execution of the <ref:tag name="x:view"/> command is <@icode{null}/>.
	       </p>
	       <p>
		  Instances of the view declaration are created for each specific view referenced.
		  If the view name has no extension there will be only one instance.
		  If the view name has an extension, then there will be a different instance
		  for each different name extension value list.
		  Instances are created on demand as needed and exist until
		  the scope containing the view command exits.
		  The body of the view command is executed for each view instance when
		  it is created. The result of that execution is discarded.
	       </p>
	    </part>
	    <part name="Examples">
	       See the <ref:example name="even"/> example.
	    </part>
		     </section:tag>
		     <section:tag name="x:while">
			<part name="Description">
			   This command loops over its body while the value
			   of its test expression is true.
			</part>
			<part name="Command Syntax">
			   <syn:cmd>
			      <ref:term name="@x:while"/>
			      <ref:nt name="exp"/>
			   </syn:cmd>
			   <p>
			      No options are permitted.
			   </p>
			</part>
			<part name="Execution Semantics">
			   The test expression is evaluated and must yield a <@icode{boolean}/> result.
			   If this result is <@icode{false}/>, then execution of the <ref:tag name="x:while"/> command
			   is complete.
			   If this result is <@icode{true}/>, then the body is executed and then
			   the entire command is executed again.
			   The result of the <ref:tag name="x:while"/> command
			   will be the result of applying <ref:numbered name="Join Rules"/> to its
			   body executions.
			</part>
			<part name="Examples">
			   <@code{
			   @x:while i < 10 {
			      g(i);
			      i := f(i)
			   }
			   }/>
			</part>
		     </section:tag>
		     </section:lettered>
		     <section:lettered name="Types" sort="fold">
			<section:name type="type" name="float">
			   <part name="Description">
			      The &xact; <@icode{float}/> type is based on the Java <@verb{"double"}/> type
			      and hold 64-bit floating-point values.
			   </part>
			   <desc:type name="float">
			      <desc:func name="sys:Add">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="float">
				   The result is the floating point sum of <@icode{float(a)}/> and <@icode{float(b)}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Sub">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="float">
				   The result is the floating point value from subtracting <@icode{float(b)}/> 
				   from <@icode{float(a)}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Minus">
				 <desc:param name="a" type="float">
				    first parameter
				 </desc:param>
				 <desc:result type="float">
				   The result is the floating point value from subtracting <@icode{a}/> from <@icode{0}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Mult">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="float">
				   The result is the floating point product of <@icode{float(a)}/> and <@icode{float(b)}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Div">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="float">
				   The result is the floating point value from dividing <@icode{float(a)}/> 
				   by <@icode{float(b)}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{float(a)}/> and <@icode{float(b)}/> have the same floating point
				    value, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{float(a)}/> and <@icode{float(b)}/> have the same floating point
				    value, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Less">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{float(a)}/> is less than <@icode{float(b)}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:LessEq">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{float(a)}/> is less than or equal to <@icode{float(b)}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Greater">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{float(a)}/> is greater than <@icode{float(b)}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:GreaterEq">
				 <desc:param name="a" type="TypeOr[int,float]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="TypeOr[int,float]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{float(a)}/> is greater than or equal to <@icode{float(b)}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Cover">
				 <desc:param name="t" type="type">
				    a type to test.
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{true}/> if <@icode{a}/> is
				     <@icode{int}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Init" self="true">
				 <desc:param name="a" type="TypeOr[int,float,string]">
				    first parameter
				 </desc:param>
				 <desc:result type="void">
				    When <@icode{a}/> satisfies the constraint in
				    the first column, then the object is initialized as specified
				    in the second column.
				    <table:table>
				       <table:row>
					  <table:item>
					     <@icode{a?int}/>   
					  </table:item>
					  <table:item>
					     The object is initialized to that integer value.
					  </table:item>
				       </table:row>
				       <table:row>
					  <table:item>
					     <@icode{a?float}/>   
					  </table:item>
					  <table:item>
					     The object is initialized to that floating point value. 
					  </table:item>
				       </table:row>
				       <table:row>
					  <table:item>
					     <@icode{a?string}/>   
					  </table:item>
					  <table:item>
					     Here the string must represent an floating point number.
					     The object is initialized to the float value
					     that the string represents.
					  </table:item>
				       </table:row>
				    </table:table>
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is a string representation of the float value.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="int">
			   <part name="Description">
			      The &xact; <@icode{int}/> type is based on the Java <@verb{"long"}/> type
			      and hold 64-bit 2's complement values.
			   </part>
			   <desc:type name="int">
			      <desc:func name="sys:Add">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="int">
				   The result is the integer sum of <@icode{a}/> and <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Sub">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="int">
				   The result is the integer value from subtracting <@icode{b}/> from <@icode{a}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Minus">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:result type="int">
				   The result is the integer value from subtracting <@icode{a}/> from <@icode{0}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Mult">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="int">
				   The result is the integer product of <@icode{a}/> and <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Div">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="int">
				   The result is the integer value from dividing <@icode{a}/> by <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Rem">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="int">
				   The result is the integer value of the remainder from dividing <@icode{a}/> by <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> have the same integer
				    value, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> have the same integer
				    value, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Less">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is less than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:LessEq">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is less than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Greater">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is greater than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:GreaterEq">
				 <desc:param name="a" type="int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is greater than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Init" self="true">
				 <desc:param name="a" type="TypeOr[int,float,string]">
				    first parameter
				 </desc:param>
				 <desc:result type="void">
				    When <@icode{a}/> satisfies the constraint in
				    the first column, then the object is initialized as specified
				    in the second column.
				    <table:table>
				       <table:row>
					  <table:item>
					     <@icode{a?int}/>   
					  </table:item>
					  <table:item>
					     The object is initialized to that integer value.
					  </table:item>
				       </table:row>
				       <table:row>
					  <table:item>
					     <@icode{a?float}/>   
					  </table:item>
					  <table:item>
					     The object is initialized to the integer part of
					     the floating point value. 
					  </table:item>
				       </table:row>
				       <table:row>
					  <table:item>
					     <@icode{a?string}/>   
					  </table:item>
					  <table:item>
					     Here the string must represent an integer.
					     The object is initialized to the integer value
					     that the string represents.
					  </table:item>
				       </table:row>
				    </table:table>
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is a string representation of the integer value.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="func">
			   <part name="Description">
			      The type <ref:name name="func"/> is the type of all functions.
			      Functions are declared using the <ref:tag name="x:func"/> tag.
			      Functions are called using the call form of <@ref:nt name="qualified"/> expressions.
			   </part>
			   <desc:type name="func">
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="func">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="func">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same function,
				    then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="func">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="func">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same function,
				    then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is the name of the function.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			   <part name="Examples">
			      <@code {
			       @x:func incr(x){x+1}
			       ~ Type[incr]==func;
			       incr(7)
			       }/>
			   </part>
			</section:name>
			<section:name type="type" name="langtype:render">
			   <part name="Description">
			      The built-in language type for rendering.
			   </part>
			   <desc:type name="langtype:render">
			      <desc:func name="sys:Init" self="true">
				 <desc:result type="void">
				    Initializes the language object.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Copy" self="true">
				 <desc:result type="myLangType">
				    Returns a copy of the language object for use in another thread.
				 </desc:result>
			      </desc:func>
			      <desc:func name="Walk" self="true">
				 <desc:param name="pass" type='enum["bind1","bind2","exec"]'>
				    the pass being performed.
				 </desc:param>
				 <desc:param name="space" type="string">
				    the name space of the command to be processed.
				    This is usually the same as <@icode{elem.space}/>,
				    but may be different during renaming.
				 </desc:param>
				 <desc:param name="base" type="string">
				    the name base of the command to be processed.
				    This is usually the same as <@icode{elem.base}/>,
				    but may be different during renaming.
				 </desc:param>
				 <desc:param name="elem" type="xdom">
				    the tree node command to be processed.
				    Note that the tag of this node is ignored;
				    <@icode{space}/> and <@icode{base}/> parameters
				    are used instead.
				 </desc:param>
				 <desc:param name="lang">
				    The language object to be used for child elements.
				    This permits two or more languages to be freely mixed.
				    For example consider language object <@icode{l1(l2())}/>
				    where <@icode{l1}/> handles <@verb{"a:"}/> tags
				    and <@icode{l2}/> handles <@verb{"b:"}/> tags.
				    When processing a <@verb{"b:"}/> element
				    <@icode{l1}/> will pass the element on to the
				    underlying <@icode{l2}/>
				    where the value of <@icode{lang}/>
				    will be <@icode{l1(l2())}/>. This permits
				    both <@verb{"a:"}/> and <@verb{"b:"}/> elements
				    to appear as children as a <@verb{"b:"}/> element.
				 </desc:param>
				 <desc:param name="info" type="rec">
				    Useful interpreter information
				    that is passed in.
				    In the bind1 pass, <@icode{info.scope#rec}/> will
				    be the enclosing scope with type <@icode{xdom:element}/>.
				 </desc:param>
				 <desc:result>
				    The result will be the pass result.
				    For bind1 and bind2 this will be <@icode{null}/>.
				    For exec this will be the result of execution
				    which in this case is rendering of the passed <@icode{elem}/>.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="langtype:xact">
			   <part name="Description">
			      The built-in language type for &xact; commands.
			      It assumes these commands have namespace <@verb{"x:"}/>.
			      Other elements are passed to the underlying language object.
			   </part>
			   <desc:type name="langtype:render">
			      <desc:func name="sys:Init" self="true">
				 <desc:param name="under" type="thread">
				    the underlying language object.
				    This parameter is not used.
				 </desc:param>
				 <desc:result type="void">
				    Initializes the language object.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Copy" self="true">
				 <desc:result type="myLangType">
				    Returns a copy of the language object for use in another thread.
				 </desc:result>
			      </desc:func>
			      <desc:func name="Walk" self="true">
				 <desc:param name="pass" type='enum["bind1","bind2","exec"]'>
				    the pass being performed.
				 </desc:param>
				 <desc:param name="space" type="string">
				    the name space of the command to be processed.
				    This is usually the same as <@icode{elem.space}/>,
				    but may be different during renaming.
				 </desc:param>
				 <desc:param name="base" type="string">
				    the name base of the command to be processed.
				    This is usually the same as <@icode{elem.base}/>,
				    but may be different during renaming.
				 </desc:param>
				 <desc:param name="elem" type="xdom">
				    the tree node command to be processed.
				    Note that the tag of this node is ignored;
				    <@icode{space}/> and <@icode{base}/> parameters
				    are used instead.
				 </desc:param>
				 <desc:param name="lang">
				    The language object to be used for child elements.
				    This permits two or more languages to be freely mixed.
				    For example consider language object <@icode{l1(l2())}/>
				    where <@icode{l1}/> handles <@verb{"a:"}/> tags
				    and <@icode{l2}/> handles <@verb{"b:"}/> tags.
				    When processing a <@verb{"b:"}/> element
				    <@icode{l1}/> will pass the element on to the
				    underlying <@icode{l2}/>
				    where the value of <@icode{lang}/>
				    will be <@icode{l1(l2())}/>. This permits
				    both <@verb{"a:"}/> and <@verb{"b:"}/> elements
				    to appear as children as a <@verb{"b:"}/> element.
				 </desc:param>
				 <desc:param name="info" type="rec">
				    Useful interpreter information
				    that is passed in.
				    In the bind1 pass, <@icode{info.scope#rec}/> will
				    be the enclosing scope with type <@icode{xdom:element}/>.
				 </desc:param>
				 <desc:result>
				    The result will be the pass result.
				    For bind1 and bind2 this will be <@icode{null}/>.
				    For exec this will be the result of execution
				    which in this case is the result of &xact; command execution.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="langtype:error">
			   <part name="Description">
			      The built-in language type for the error language.
			      It fails with an error if its <@icode{Walk}/> function
			      is called.
			   </part>
			   <desc:type name="langtype:error">
			      <desc:func name="sys:Init" self="true">
				 <desc:result type="void">
				    Initializes the language object.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Copy" self="true">
				 <desc:result type="myLangType">
				    Returns a copy of the language object for use in another thread.
				 </desc:result>
			      </desc:func>
			      <desc:func name="Walk" self="true">
				 <desc:param name="pass" type='enum["bind1","bind2","exec"]'>
				    the pass being performed.
				 </desc:param>
				 <desc:param name="space" type="string">
				    the name space of the command to be processed.
				    This is usually the same as <@icode{elem.space}/>,
				    but may be different during renaming.
				 </desc:param>
				 <desc:param name="base" type="string">
				    the name base of the command to be processed.
				    This is usually the same as <@icode{elem.base}/>,
				    but may be different during renaming.
				 </desc:param>
				 <desc:param name="elem" type="xdom">
				    the tree node command to be processed.
				    Note that the tag of this node is ignored;
				    <@icode{space}/> and <@icode{base}/> parameters
				    are used instead.
				 </desc:param>
				 <desc:param name="lang">
				    The language object to be used for child elements.
				    This permits two or more languages to be freely mixed.
				    For example consider language object <@icode{l1(l2())}/>
				    where <@icode{l1}/> handles <@verb{"a:"}/> tags
				    and <@icode{l2}/> handles <@verb{"b:"}/> tags.
				    When processing a <@verb{"b:"}/> element
				    <@icode{l1}/> will pass the element on to the
				    underlying <@icode{l2}/>
				    where the value of <@icode{lang}/>
				    will be <@icode{l1(l2())}/>. This permits
				    both <@verb{"a:"}/> and <@verb{"b:"}/> elements
				    to appear as children as a <@verb{"b:"}/> element.
				 </desc:param>
				 <desc:param name="info" type="rec">
				    Useful interpreter information
				    that is passed in.
				    In the bind1 pass, <@icode{info.scope#rec}/> will
				    be the enclosing scope with type <@icode{xdom:element}/>.
				 </desc:param>
				 <desc:result type="void">
				    Calling this function will always be an error.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="lock">
			   <part name="Description">
			      The <@icode{lock}/> type is
			      is used for low-level multithread synchronization.
			      It is based on the operations of the Java <@verb{"Object"}/> type.
			      The <ref:tag name="x:exclude"/> command is used for mutual exclusion
			      (or more generally to define a monitor)
			      based on a specified <@icode{lock}/> object.
			   </part>
			   <desc:type name="lock">
			      <desc:func name="wait" type="void">
				 <desc:varparam name="L">
				    There are three possible parameter forms.
				    If there are no parameters then there is no timeout.
				    If there is one parameter, then that <@icode{int}/> value
				    will be a number of milliseconds for a timeout.
				    If the are two parameters, then the first will be an <@icode{int}/> millisecond
				    value and the second will be an <@icode{int}/> microsecond value that
				    are added to form the timeout interval.
				 </desc:varparam>
				 <desc:result>
				    <p>
				       This call must appear within a <ref:tag name="x:exclude"/> command
				       for this lock.
				       The current thread then waits until another thread calls
				       <@icode{notify}/> or <@icode{notifyAll}/> for this lock.
				    </p>
				    <p>
				       If a timeout is specified, the wait will also end without any notify
				       if the timeout interval has elapsed.
				    </p>
				 </desc:result>
			      </desc:func>
			      <desc:func name="notify" type="void">
				 <desc:result>
				 This call must appear within a <ref:tag name="x:exclude"/> command
				 for this lock.
				 If any other threads are waiting on this lock, then an arbitrary one is selected
				 to be awakened.
				 That thread will, however, not be able to proceed until
				 the current thread also exits the enclosing <ref:tag name="x:exclude"/> command
				 for this lock.
				 </desc:result>
			      </desc:func>
			      <desc:func name="notifyAll" type="void">
				 <desc:result>
				 This call must appear within a <ref:tag name="x:exclude"/> command
				 for this lock.
				 If any other threads are waiting on this lock, then all are awakened.
				 These threads will, however, not be able to proceed until
				 the current thread also exits the enclosing <ref:tag name="x:exclude"/> command
				 for this lock.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="lock">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="lock">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same lock,
				    then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="lock">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="lock">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same lock,
				    then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Init" self="true">
				 <desc:result type="void">
				    Initializes a new lock object.
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is the string <@icode{"lock"}/>.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="queue">
			   <part name="Description">
			      <p>
				 The <@icode{queue}/> type is
				 is used for high-level multithread synchronization.
				 One thread sends values to the queue, while another thread
				 receives those values.
			     </p>
			      <p>
				 The <ref:example name="queue"/> examples
				 shows how a type with the same semantics as
				 <@icode{queue}/> can be implemented using
				 <@icode{lock}/>s.
			      </p>
			   </part>
			   <desc:type name="queue">
			      <desc:func name="send" self="true">
				 <desc:param name="val">
				    A value to be sent.
				 </desc:param>
				 <desc:result type="void">
				    Sends a value to the queue.
				    Waits if queue is full.
				 </desc:result>
			      </desc:func>
			      <desc:func name="receive" self="true">
				 <desc:result>
				    Receives and returns a value from the queue.
				    Waits if the queue is empty.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="queue">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="queue">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same queue,
				    then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="queue">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="queue">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same queue,
				    then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Init" self="true">
				 <desc:param name="count" type="int">
				    A queue size.
				 </desc:param>
				 <desc:result type="void">
				    Initializes a new queue object of size specified by <@icode{size}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is the string <@icode{"queue"}/>.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="stream">
			   <part name="Description">
			      The <@icode{stream}/> type is
			      is used for high-level multithread synchronization.
			      One thread sends strings to the stream, while another
			      thread receives the concatenated results.
			   </part>
			   <desc:type name="stream">
			      <desc:func name="send" self="true">
				 <desc:param name="val" type="string">
				    A string value to be sent.
				 </desc:param>
				 <desc:result type="void">
				    Sends a value to the queue.
				    Waits if queue is full.
				 </desc:result>
			      </desc:func>
			      <desc:func name="close" self="true">
				 <desc:result type="void">
				    This function should be called after all calls to <@icode{send}/>
				    to close the stream.
				    The <@icode{receive}/> call will not complete until <@icode{close}/> is called.
				 </desc:result>
			      </desc:func>
			      <desc:func name="receive" self="true">
				 <desc:result type="string">
				    Receives and returns a value from the queue.
				    Waits if the queue is empty.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="stream">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="stream">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same stream,
				    then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="stream">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="stream">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same stream,
				    then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Init" self="true">
				 <desc:varparam name="L">
				    This can be either empty or a single <@icode{int}/> size.
				 </desc:varparam>
				 <desc:result type="void">
				    Initializes a new stream object of size specified by the count
				    (or size 1 if the count is not specified).
				    This count is the number of sent <@icode{strings}/> that can be held
				    in the stream.
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is the string <@icode{"stream"}/>.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="string">
			   <part name="Description">
			      <p>
			      The &xact; <@icode{string}/> type is based on the Java <@verb{"String"}/> type
			      and holds sequences of 16-bit characters.
			      Unlike Java that uses reference semantics for string <@verb{"=="}/> equality,
			      in &xact; <ref:inop name="=="/> string equality is always value equality that
			      compares the characters in the string.
			      </p>
			      <p>
				 String iterators include <@icode{Chars[s]}/> and <@icode{Lines[s]}/>.
			      </p>
			      <p>
				 Views of string include <@icode{boolean}/>, <@icode{fold}/>, <@icode{date}/>,
				 and <@icode{file}/>.
			      </p>
			      <p>
				 Examples of how to use the date view
				 can be found in the <ref:example name="string"/> example.
			      </p>
			   </part>
			   <desc:type name="string">
			      <desc:func name="sys:Cat">
				 <desc:param name="a">
				    first parameter
				 </desc:param>
				 <desc:param name="b">
				    second parameter
				 </desc:param>
				 <desc:result type="string">
				    The result is the string concatenation
				    of <@icode{string(a)}/> and <@icode{string(b)}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> have the same size and
				    same characters, then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> have the same size and
				    same characters, then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Less">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is less than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:LessEq">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is less than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Greater">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is greater than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:GreaterEq">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is greater than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Init" self="true">
				 <desc:param name="a">
				    first parameter
				 </desc:param>
				 <desc:result type="void">
				    <p>
				       There are two forms of string constructor:
				       a special single character constructor and
				       a general purpose string constructor.
				    </p>
				    <p>
				       For the special single character constructor, <@icode{a}/> should
				       have the form <@icode{code=nnn}/> where <@icode{nnn}/> is an integer
				       value in the range <@icode{0}/> to <@icode{65535}/>.
				       The result will be a string with a single character
				       whose internal code was given by <@icode{n}/>.
				    </p>
				    <p>
				       All other cases are general purpose string constructors.
				       If <@icode{a?string}/> then the object is initialized to
					<@code{a}/>
					otherwise the object is initialized to
					<@code{Type[a].toString()}/>
				    </p>
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Subscript" self="true">
				 <desc:param name="index">
				    The subscript.
				 </desc:param>
				 <desc:result>
				    <p>
				       There are two kinds of string subscript:
				       character subscript and substring.
				    </p>
				    <p>
				       For a character subscript of a string <@icode{s}/>, <@icode{index}/> should
				       be an integer in the range <@icode{0}/> to <@icode{s.size}/>.
				       The result will be the integer character code for the <@icode{index}/>'th
				       character. The value will be in the range <@icode{0..65535}/>.
				    </p>
				    <p>
				       For a substring of a string <@icode{s}/>, <@icode{index}/> should
				       have the form <@icode{i..j}/> where <@icode{i}/> and <@icode{j}/> have
				       type <@icode{int}/>.
				       If <@icode{i==j+1}/> the result is the empty string (<@icode{""}/>).
				       Otherwise we require <@icode{1 <= i & i <= j & j <= s.size}/>.
				       In this case the result will be the substring of <@icode{s}/> containing
				       character in positions <@icode{i}/> through <@icode{j}/> inclusive.
				    </p>
				 </desc:result>
			      </desc:func>
			      <desc:const name="size" type="int" self="true">
				The number of character in the string.
			      </desc:const>
			   </desc:type>
			</section:name>
			<section:name type="type" name="thread">
			   <part name="Description">
			      The <@icode{thread}/> type is used to represent threads and
			      is based on the Java <@verb{"Thread"}/> type.
			      Threads are created with the <ref:name name="x:thread"/> command.
			   </part>
			   <desc:type name="thread">
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="func">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="func">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same thread,
				    then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="func">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="func">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same thread,
				    then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is the name of the thread.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="type">
			   <part name="Description">
			      The type <ref:name name="type"/> is the type of all types.
			      Types are declared using the <ref:tag name="x:type"/> tag.
			      Objects of a type are constructed using the constructor form
			      of <ref:nt name="qualified"/> expressions.
			   </part>
			   <desc:type name="type">
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="type">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="type">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same type,
				    then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="type">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="type">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same type,
				    then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is a string that represents the type.
				    It includes the type name.
				    If the type name includes an extension, 
				    extension value strings are included.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			   <part name="Examples">
			      <@code {
			       @x:type t;
			       ~ Type[t]==type;
			       ~ Type[t()]==t;
			       }/>
			   </part>
			</section:name>
			<section:name type="type" name="view">
			   <part name="Description">
			      The type <ref:name name="view"/> is the type of all views.
			      Views are declared using the <ref:tag name="x:view"/> tag.
			      Objects of a type are constructed using the constructor form
			      of <ref:nt name="qualified"/> expressions.
			   </part>
			   <desc:type name="view">
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="view">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="view">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same view,
				    then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="view">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="view">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same view,
				    then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is a string that represents the view.
				    It includes the view name.
				    If the view name includes an extension, 
				    extension value strings are included.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			   <part name="Examples">
			      <@code {
			       @x:view v;
			       ~ Type[v]==view;
			       ~ Type[v()]!=v;
			       }/>
			   </part>
			</section:name>
			<section:name type="type" name="void">
			   <part name="Description">
			      The <@icode{void}/> type is
			      the type of the single <@icode{null}/> value.
			      &xact; <@icode{void}/> and <@icode{null}/> work similarly to
			      the Java concepts with the same names.
			   </part>
			   <desc:type name="void">
			      <desc:func name="toString" self="true">
				 <desc:result type="string">
				    The result is the string <@icode{"null"}/>.
				 </desc:result>
			      </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="type" name="xdom:call">
			   <part name="Description">
			      The <@icode{xdom:call}/> type is used to
			      represent call nodes within an <@icode{xdom}/> tree.
			   </part>
			   <desc:type name="xdom:call">
			      <desc:func name="sys:Init" self="true">
			         <desc:param name="func" type="xdom">
				    the xdom for the function to be called.
				 </desc:param>
				 <desc:nparam name="list" type="TypeOr[list,void]" default="null" optional="true">
				    the list of function parameters
				    If <@icode{null}/>, the result will have no parameters.
				 </desc:nparam>
				 <desc:nparam name="noStep" type="boolean" default="false" optional="true">
				    sets <@icode{self.noStep}/>
				 </desc:nparam>
				 <desc:nparam name="breakBefore" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakBefore}/>
				 </desc:nparam>
				 <desc:nparam name="breakAfter" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakAfter}/>
				 </desc:nparam>
				 <desc:nparam name="mark1" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark1}/>
				 </desc:nparam>
				 <desc:nparam name="mark2" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark2}/>
				 </desc:nparam>
				 <desc:nparam name="mark3" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark3}/>
				 </desc:nparam>
				 <desc:nparam name="label" type="boolean" default='""' optional="true">
				    sets <@icode{self.label}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBefore}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfter}/>
				 </desc:nparam>
				 <desc:nparam name="kind"
					      type='enum["normal","op","dot","double","single","long","short","subscript","list"]'
					   default='"normal"' optional="true">
				    sets <@icode{self.kind}/>
				 </desc:nparam>
				 <desc:result type="void">
				 Initializes a new <@icode{xdom:call}/> tree node.
				 </desc:result>
			      </desc:func>
			      <desc:var name="func" type="xdom" self="true">
			      The tree for the function being called.
			      </desc:var>
			      <desc:const name="size" type="int" self="true">
			         The number of <@icode{xdom}/> tree nodes that are parameters of the call.
			      </desc:const>
			      <desc:func name="sys:Subscript" self="true" kind="lhs/rhs">
				 <desc:param name="index" type="int">
				    The index of the parameter
				    to be selected.
				    For call <@icode{c}/> this
				    must be in the range <@icode{1..c.size}/>.
				 </desc:param>
				 <desc:result>
				    The <@icode{index}/>th parameter.
				 </desc:result>
			      </desc:func>
			      <desc:func name="insert" self="true">
				 <desc:param name="val">
				    a value to be inserted
				 </desc:param>
				 <desc:param name="pos" type="int" default="self.size" optional="true">
				    the value must be in the range <@icode{0..self.size}/>.
				 </desc:param>
				 <desc:result type="void">
				    Inserts the new value at the specified position.
				    If the position is <@icode{0}/>, the value is inserted
				    at the beginning of the parameter list.
				    Otherwise, the value is inserted after the <@icode{pos}/> parameter.
				 </desc:result>
			      </desc:func>
			      <desc:func name="delete" self="true">
				 <desc:param name="pos" type="int" optional="true">
				    for call <@icode{c}/>,
				    the value must be in the range <@icode{1..c.size}/>.
				 </desc:param>
				 <desc:result type="void">
				    The parameter at the specified position is deleted from the
				    parameter list.
				 </desc:result>
			      </desc:func>
			      <desc:const name="all" self="true" type="func">
				 An iterator function that iterates over all the parameters.
			      </desc:const>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="xdom:call">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:call">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="xdom:call">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:call">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:var name="noStep" type="boolean" self="true">
				The debugger should not break before or after this node when in single step mode.
			      </desc:var>
			      <desc:var name="breakBefore" type="boolean" self="true">
				The debugger should break before executing this node.
			      </desc:var>
			      <desc:var name="breakAfter" type="boolean" self="true">
				The debugger should break after executing this node.
			      </desc:var>
			      <desc:var name="mark1" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark2" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark3" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="label" type="string" self="true">
			         A label name used when unparsing directed graphs.
			      </desc:var>
			      <desc:var name="spaceBefore" type='enum["empty","space","line","lines","erase"]' self="true">
			         The amount of space present between the last non-blank character before 
				 this <@icode{xdom}/> item and the beginning of this xdom item.
			      </desc:var>
			      <desc:var name="spaceAfter" type='enum["empty","space","line","lines","erase"]'  self="true">
			         The amount of space present between the end of 
				 this <@icode{xdom}/> item and the next non-blank character.
			      </desc:var>
			      <desc:var name="kind" 
			      type='enum["normal","op","dot","double","single","long","short","subscript","list"]'
			      self="true">
			        <p>
				The kind of syntactic sugar for this element.
				</p>
				<table:table>
				<table:row>
				   <table:item>
				      <@icode{"normal"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      f(x)
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"op"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      a + b
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"dot"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      a.b
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"double"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      "abc&foo;def"
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"single"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      'abc&foo;def'
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"long"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      x:/* a long comment */
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"short"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      x:// comment
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"subscript"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      f(x)#v
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"list"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      [2,3]
				      }/>
				   </table:item>
				</table:row>
				</table:table>
			      </desc:var>
			   </desc:type>
			</section:name>
			<section:name type="type" name="xdom:element">
			   <part name="Description">
			      <p>
			      The <@icode{xdom:element}/> type is used to
			      represent &xact; commands and XML element nodes within an <@icode{xdom}/> tree.
			      </p>
			      <p>
				 Subscripting of an <@icode{xdom:element}/> provides array access.
				 The <@icode{i}/>th element will be the value of the <@icode{i}/>th
				 unnamed attribute.
			      </p>
			      <p>
				 Views of <@icode{xdom:element}/> include <@icode{rec}/>, <@icode{attr}/>, <@icode{body}/>, <@icode{bodyrec}/>, @icode{array}/>, and <@icode{list}/>.
				 These views provide subscripting based on other views of the list of attributes and
				 body subtrees.
			      </p>
			   </part>
			   <desc:type name="xdom:element">
			      <desc:func name="sys:Init" self="true">
			         <desc:param name="tag" type="string">
				 the tag for the new element.
				 </desc:param>
				 <desc:nparam name="attr" type="TypeOr[rec,void]" default="null" optional="true">
				 the set of initial attributes.
				 If <@icode{null}/>, the result will have no attributes.
				 </desc:nparam>
				 <desc:nparam name="body" type="TypeOr[list,void]" default="null" optional="true">
				 the list of body <@icode{xdom}/> tree nodes.
				 If <@icode{null}/>, the body of the result will be empty.
				 </desc:nparam>
				 <desc:nparam name="noStep" type="boolean" default="false" optional="true">
				    sets <@icode{self.noStep}/>
				 </desc:nparam>
				 <desc:nparam name="breakBefore" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakBefore}/>
				 </desc:nparam>
				 <desc:nparam name="breakAfter" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakAfter}/>
				 </desc:nparam>
				 <desc:nparam name="mark1" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark1}/>
				 </desc:nparam>
				 <desc:nparam name="mark2" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark2}/>
				 </desc:nparam>
				 <desc:nparam name="mark3" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark3}/>
				 </desc:nparam>
				 <desc:nparam name="label" type="boolean" default='""' optional="true">
				    sets <@icode{self.label}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBefore}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfter}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBeforeBody" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBeforeBody}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfterBody" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfterBody}/>
				 </desc:nparam>
				 <desc:nparam name="kind"
					type='enum["normal","xml","iterator","xmldecl","short","long"]'
					   default='"normal"' optional="true">
				    sets <@icode{self.kind}/>
				 </desc:nparam>
				 <desc:result type="void">
				 Initializes a new <@icode{xdom:element}/> tree node.
				 </desc:result>
			      </desc:func>
			      <desc:var name="tag" type="string" self="true">
			          The command name / XML element tag.
			      </desc:var>
			      <desc:var name="space" type="string" self="true">
			         The part of <@icode{tag}/> before the first <@verb{":"}/>
				 or <@icode{""}/> if there is no <@verb{":"}/>.
			      </desc:var>
			      <desc:var name="base" type="string" self="true">
			         The part of <@icode{tag}/> after the first <@verb{":"}/>
				 or the entire <@icode{tag}/> if there is no <@verb{":"}/>.
			      </desc:var>
			      <desc:const name="size" type="int" self="true">
			         The number of array elements (unnamed attributes).
			      </desc:const>
			      <desc:func name="sys:Subscript" self="true" kind="lhs/rhs">
				 <desc:param name="index" type="int">
				    The index of the array element (unnamed attribute)
				    to be selected.
				    For element <@icode{e}/> this
				    must be in the range <@icode{1..e.size}/>.
				 </desc:param>
				 <desc:result>
				    The <@icode{index}/>th array element (unnamed attribute)
				    value.
				 </desc:result>
			      </desc:func>
			      <desc:func name="insert" self="true">
				 <desc:param name="val">
				    a value to be inserted
				 </desc:param>
				 <desc:param name="pos" type="int" default="self.size" optional="true">
				    the value must be in the range <@icode{0..self.size}/>.
				 </desc:param>
				 <desc:result type="void">
				    Inserts the new value at the specified position.
				    If the position is <@icode{0}/>, the value is inserted
				    at the beginning of the array.
				    Otherwise, the value is inserted after the <@icode{pos}/> element.
				 </desc:result>
			      </desc:func>
			      <desc:func name="delete" self="true">
				 <desc:param name="pos" type="int" optional="true">
				    for element <@icode{e}/>,
				    the value must be in the range <@icode{1..e.size}/>.
				 </desc:param>
				 <desc:result type="void">
				    The element at the specified position is deleted from the array.
				 </desc:result>
			      </desc:func>
			      <desc:const name="all" self="true" type="func">
				 An iterator function that iterates over all the array elements.
			      </desc:const>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="xdom:element">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:element">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="xdom:element">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:element">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:var name="noStep" type="boolean" self="true">
				The debugger should not break before or after this node when in single step mode.
			      </desc:var>
			      <desc:var name="breakBefore" type="boolean" self="true">
				The debugger should break before executing this node.
			      </desc:var>
			      <desc:var name="breakAfter" type="boolean" self="true">
				The debugger should break after executing this node.
			      </desc:var>
			      <desc:var name="mark1" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark2" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark3" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="label" type="string" self="true">
			         A label name used when unparsing directed graphs.
			      </desc:var>
			      <desc:var name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					 self="true">
			         The amount of space present between the last non-blank character before 
				 this <@icode{xdom}/> item and the beginning of this xdom item.
			      </desc:var>
			      <desc:var name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					 self="true">
			         The amount of space present between the end of 
				 this <@icode{xdom}/> item and the next non-blank character.
			      </desc:var>
			      <desc:var name="spaceBeforeBody" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the end of the start tag and the first
				 non-blank character of the body.
			      </desc:var>
			      <desc:var name="spaceAfterBody" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the last non-blank character of the body
				 and the beginning of the end tag.
			      </desc:var>
			      <desc:var name="kind"
					type='enum["normal","xml","iterator","xmldecl","short","long"]'
					self="true">
			        <p>
				The kind of syntactic sugar for this element.
				</p>
				<table:table>
				<table:row>
				   <table:item>
				      <@icode{"normal"}/>
				   </table:item>
				   <table:item>
				      <@icode{@foo { bar }}/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"xml"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      <foo>bar</foo>
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"iterator"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      @x:for i:=1..10 { i }
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"xmldecl"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      <?xml version="1.0" encoding="UTF-8" ?>
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"short"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				         // short comment
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"long"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				         /* long comment
					    over several lines */
				      }/>
				   </table:item>
				</table:row>
				</table:table>
			      </desc:var>
			   </desc:type>
			</section:name>
			<section:name type="type" name="xdom:name">
			   <part name="Description">
			      The <@icode{xdom:name}/> type is used to
			      represent name nodes within an <@icode{xdom}/> tree.
			   </part>
			   <desc:type name="xdom:name">
			      <desc:func name="sys:Init" self="true">
			         <desc:param name="id" type="string">
				    the identifier part of the name
				 </desc:param>
				 <desc:nparam name="list" type="TypeOr[list,void]" default="null" optional="true">
				    the list of name extension nodes.
				    If <@icode{null}/>, the result will have no name extension.
				 </desc:nparam>
				 <desc:nparam name="noStep" type="boolean" default="false" optional="true">
				    sets <@icode{self.noStep}/>
				 </desc:nparam>
				 <desc:nparam name="breakBefore" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakBefore}/>
				 </desc:nparam>
				 <desc:nparam name="breakAfter" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakAfter}/>
				 </desc:nparam>
				 <desc:nparam name="mark1" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark1}/>
				 </desc:nparam>
				 <desc:nparam name="mark2" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark2}/>
				 </desc:nparam>
				 <desc:nparam name="mark3" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark3}/>
				 </desc:nparam>
				 <desc:nparam name="label" type="boolean" default='""' optional="true">
				    sets <@icode{self.label}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBefore}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfter}/>
				 </desc:nparam>
				 <desc:nparam name="kind"
					type='enum["normal","xml"]'
					   default='"normal"' optional="true">
				    sets <@icode{self.kind}/>
				 </desc:nparam>
				 <desc:result type="void">
				 Initializes a new <@icode{xdom:name}/> tree node.
				 </desc:result>
			      </desc:func>
			      <desc:var name="val" type="string" self="true">
				The contained name.
			      </desc:var>
			      <desc:var name="space" type="string" self="true">
				The part of the contained name before 
				the first <@verb{":"}/> or <@icode{""}/> if there is no <@verb{":"}/>.
			      </desc:var>
			      <desc:var name="base" type="string" self="true">
			      The part of the contained name after the first <@verb{":"}/> or <@icode{val}/> if there
			      is no <@verb{":"}/>.
			      </desc:var>
			      <desc:var name="hasExt" type="boolean" self="true">
			      The name has a name extension.
			      </desc:var> 
			      <desc:const name="size" type="int" self="true">
			         The number of <@icode{xdom}/> tree nodes that are within the name
				 extension.
			      </desc:const>
			      <desc:func name="sys:Subscript" self="true" kind="lhs/rhs">
				 <desc:param name="index" type="int">
				    The index of the name extension item
				    to be selected.
				    For name node <@icode{n}/> this
				    must be in the range <@icode{1..n.size}/>.
				 </desc:param>
				 <desc:result>
				    The <@icode{index}/>th name extension item
				    value.
				 </desc:result>
			      </desc:func>
			      <desc:func name="insert" self="true">
				 <desc:param name="val">
				    a value to be inserted
				 </desc:param>
				 <desc:param name="pos" type="int" default="self.size" optional="true">
				    the value must be in the range <@icode{0..self.size}/>.
				 </desc:param>
				 <desc:result type="void">
				    Inserts the new value at the specified position.
				    If the position is <@icode{0}/>, the value is inserted
				    at the beginning of the name extension list.
				    Otherwise, the value is inserted after the <@icode{pos}/> item of the list.
				 </desc:result>
			      </desc:func>
			      <desc:func name="delete" self="true">
				 <desc:param name="pos" type="int" optional="true">
				    for name node <@icode{n}/>,
				    the value must be in the range <@icode{1..n.size}/>.
				 </desc:param>
				 <desc:result type="void">
				    The element at the specified position is deleted from the name extension list.
				 </desc:result>
			      </desc:func>
			      <desc:const name="all" self="true" type="func">
				 An iterator function that iterates over the extension list.
			      </desc:const>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="xdom:name">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:name">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="xdom:name">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:name">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:var name="noStep" type="boolean"  self="true">
				The debugger should not break before or after this node when in single step mode.
			      </desc:var>
			      <desc:var name="breakBefore" type="boolean" self="true">
				The debugger should break before executing this node.
			      </desc:var>
			      <desc:var name="breakAfter" type="boolean" self="true">
				The debugger should break after executing this node.
			      </desc:var>
			      <desc:var name="mark1" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark2" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark3" type="boolean"  self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="label" type="string" self="true">
			         A label name used when unparsing directed graphs.
			      </desc:var>
			      <desc:var name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the last non-blank character before 
				 this <@icode{xdom}/> item and the beginning of this xdom item.
			      </desc:var>
			      <desc:var name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the end of 
				 this <@icode{xdom}/> item and the next non-blank character.
			      </desc:var>
			      <desc:var name="kind"
					type='enum["normal","xml"]'
					self="true">
			        <p>
				The kind of syntactic sugar for this element.
				</p>
				<table:table>
				<table:row>
				   <table:item>
				      <@icode{"normal"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      theName
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"xml"}/>
				   </table:item>
				   <table:item>
				      <@icode{
				      <foo>&theName;</foo>
				      }/>
				   </table:item>
				</table:row>
				</table:table>
			      </desc:var>
			   </desc:type>
			</section:name>
			<section:name type="type" name="xdom:int">
			   <part name="Description">
			      The <@icode{xdom:int}/> type is used to
			      represent <@icode{int}/> value within an <@icode{xdom}/> tree.
			   </part>
			   <desc:type name="xdom:int">
			      <desc:func name="sys:Init" self="true">
			         <desc:param name="val" type="int">
				    the integer value.
				 </desc:param>
				 <desc:nparam name="noStep" type="boolean" default="false" optional="true">
				    sets <@icode{self.noStep}/>
				 </desc:nparam>
				 <desc:nparam name="breakBefore" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakBefore}/>
				 </desc:nparam>
				 <desc:nparam name="breakAfter" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakAfter}/>
				 </desc:nparam>
				 <desc:nparam name="mark1" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark1}/>
				 </desc:nparam>
				 <desc:nparam name="mark2" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark2}/>
				 </desc:nparam>
				 <desc:nparam name="mark3" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark3}/>
				 </desc:nparam>
				 <desc:nparam name="label" type="boolean" default='""' optional="true">
				    sets <@icode{self.label}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBefore}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfter}/>
				 </desc:nparam>
				 <desc:result type="void">
				 Initializes a new <@icode{xdom:int}/> tree node.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="xdom:int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="xdom:int">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:int">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:var name="noStep" type="boolean" self="true">
				The debugger should not break before or after this node when in single step mode.
			      </desc:var>
			      <desc:var name="breakBefore" type="boolean" self="true">
				The debugger should break before executing this node.
			      </desc:var>
			      <desc:var name="breakAfter" type="boolean" self="true">
				The debugger should break after executing this node.
			      </desc:var>
			      <desc:var name="mark1" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark2" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark3" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="label" type="string" self="true">
			         A label name used when unparsing directed graphs.
			      </desc:var>
			      <desc:var name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the last non-blank character before 
				 this <@icode{xdom}/> item and the beginning of this xdom item.
			      </desc:var>
			      <desc:var name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the end of 
				 this <@icode{xdom}/> item and the next non-blank character.
			      </desc:var>
			      <desc:var name="val" type="int" self="true">
			      The contained int value.
			      </desc:var>
			   </desc:type>
			</section:name>
			<section:name type="type" name="xdom:float">
			   <part name="Description">
			      The <@icode{xdom:float}/> type is used to
			      represent <@icode{float}/> value nodes within an <@icode{xdom}/> tree.
			   </part>
			   <desc:type name="xdom:float">
			      <desc:func name="sys:Init" self="true">
			         <desc:param name="val" type="float">
				    the float value.
				 </desc:param>
				 <desc:nparam name="noStep" type="boolean" default="false" optional="true">
				    sets <@icode{self.noStep}/>
				 </desc:nparam>
				 <desc:nparam name="breakBefore" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakBefore}/>
				 </desc:nparam>
				 <desc:nparam name="breakAfter" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakAfter}/>
				 </desc:nparam>
				 <desc:nparam name="mark1" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark1}/>
				 </desc:nparam>
				 <desc:nparam name="mark2" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark2}/>
				 </desc:nparam>
				 <desc:nparam name="mark3" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark3}/>
				 </desc:nparam>
				 <desc:nparam name="label" type="boolean" default='""' optional="true">
				    sets <@icode{self.label}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBefore}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfter}/>
				 </desc:nparam>
				 <desc:result type="void">
				 Initializes a new <@icode{xdom:float}/> tree node.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="xdom:float">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:float">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="xdom:float">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:float">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:var name="noStep" type="boolean" self="true">
				The debugger should not break before or after this node when in single step mode.
			      </desc:var>
			      <desc:var name="breakBefore" type="boolean" self="true">
				The debugger should break before executing this node.
			      </desc:var>
			      <desc:var name="breakAfter" type="boolean" self="true">
				The debugger should break after executing this node.
			      </desc:var>
			      <desc:var name="mark1" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark2" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark3" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="label" type="string" self="true">
			         A label name used when unparsing directed graphs.
			      </desc:var>
			      <desc:var name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the last non-blank character before 
				 this <@icode{xdom}/> item and the beginning of this xdom item.
			      </desc:var>
			      <desc:var name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the end of 
				 this <@icode{xdom}/> item and the next non-blank character.
			      </desc:var>
			      <desc:var name="val" type="float" self="true">
			      The contained float value.
			      </desc:var>
			   </desc:type>
			</section:name>
			<section:name type="type" name="xdom:string">
			   <part name="Description">
			      The <@icode{xdom:string}/> type is used to
			      represent <@icode{string}/> nodes within an <@icode{xdom}/> tree.
			   </part>
			   <desc:type name="xdom:string">
			      <desc:func name="sys:Init" self="true">
			         <desc:param name="val" type="string">
				    the string value
				 </desc:param>
				 <desc:nparam name="noStep" type="boolean" default="false" optional="true">
				    sets <@icode{self.noStep}/>
				 </desc:nparam>
				 <desc:nparam name="breakBefore" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakBefore}/>
				 </desc:nparam>
				 <desc:nparam name="breakAfter" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakAfter}/>
				 </desc:nparam>
				 <desc:nparam name="mark1" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark1}/>
				 </desc:nparam>
				 <desc:nparam name="mark2" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark2}/>
				 </desc:nparam>
				 <desc:nparam name="mark3" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark3}/>
				 </desc:nparam>
				 <desc:nparam name="label" type="boolean" default='""' optional="true">
				    sets <@icode{self.label}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBefore}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfter}/>
				 </desc:nparam>
				 <desc:nparam name="kind"
					type='enum["single","double","xml","comment"]'
					   default='"double"' optional="true">
				    sets <@icode{self.kind}/>
				 </desc:nparam>
				 <desc:result type="void">
				 Initializes a new <@icode{xdom:string}/> tree node.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="xdom:string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="xdom:string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:var name="noStep" type="boolean" self="true">
				The debugger should not break before or after this node when in single step mode.
			      </desc:var>
			      <desc:var name="breakBefore" type="boolean" self="true">
				The debugger should break before executing this node.
			      </desc:var>
			      <desc:var name="breakAfter" type="boolean" self="true">
				The debugger should break after executing this node.
			      </desc:var>
			      <desc:var name="mark1" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark2" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark3" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="label" type="string"  self="true">
			         A label name used when unparsing directed graphs.
			      </desc:var>
			      <desc:var name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the last non-blank character before 
				 this <@icode{xdom}/> item and the beginning of this xdom item.
			      </desc:var>
			      <desc:var name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the end of 
				 this <@icode{xdom}/> item and the next non-blank character.
			      </desc:var>
			      <desc:var name="kind"
					type='enum["single","double","xml","comment"]'
					self="true">
			        <p>
				The kind of syntactic sugar for this element.
				</p>
				<table:table>
				<table:row>
				   <table:item>
				      <@icode{"single"}/>
				   </table:item>
				   <table:item>
				      <@code{
					'the string'
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"double"}/>
				   </table:item>
				   <table:item>
				      <@code{
				      "the string"
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"xml"}/>
				   </table:item>
				   <table:item>
				      <@code{
				      <foo>the string</foo>
				      }/>
				   </table:item>
				</table:row>
				<table:row>
				   <table:item>
				      <@icode{"comment"}/>
				   </table:item>
				   <table:item>
				      <@code{
				      <foo>
				         <!--the string-->
				      </foo>
				      }/>
				   </table:item>
				</table:row>
				</table:table>
			      </desc:var>
			      <desc:var name="val" type="string" self="true">
			      The contained string value.
			      </desc:var>
			   </desc:type>
			</section:name>
			<section:name type="type" name="xdom:value">
			   <part name="Description">
			      The <@icode{xdom:value}/> type is used to
			      represent value nodes (containing arbitrary &xact; values) within an <@icode{xdom}/> tree.
			   </part>
			   <desc:type name="xdom:value">
			      <desc:func name="sys:Init" self="true">
			         <desc:param name="val">
				    the value.
				 </desc:param>
				 <desc:nparam name="noStep" type="boolean" default="false" optional="true">
				    sets <@icode{self.noStep}/>
				 </desc:nparam>
				 <desc:nparam name="breakBefore" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakBefore}/>
				 </desc:nparam>
				 <desc:nparam name="breakAfter" type="boolean" default="false" optional="true">
				    sets <@icode{self.breakAfter}/>
				 </desc:nparam>
				 <desc:nparam name="mark1" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark1}/>
				 </desc:nparam>
				 <desc:nparam name="mark2" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark2}/>
				 </desc:nparam>
				 <desc:nparam name="mark3" type="boolean" default="false" optional="true">
				    sets <@icode{self.mark3}/>
				 </desc:nparam>
				 <desc:nparam name="label" type="boolean" default='""' optional="true">
				    sets <@icode{self.label}/>
				 </desc:nparam>
				 <desc:nparam name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceBefore}/>
				 </desc:nparam>
				 <desc:nparam name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					   default='"line"' optional="true">
				    sets <@icode{self.spaceAfter}/>
				 </desc:nparam>
				 <desc:result type="void">
				 Initializes a new <@icode{xdom:element}/> tree node.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="xdom:value">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:value">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="xdom:value">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="xdom:value">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> are the same tree
				    node, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:var name="noStep" type="boolean" self="true">
				The debugger should not break before or after this node when in single step mode.
			      </desc:var>
			      <desc:var name="breakBefore" type="boolean" self="true">
				The debugger should break before executing this node.
			      </desc:var>
			      <desc:var name="breakAfter" type="boolean" self="true">
				The debugger should break after executing this node.
			      </desc:var>
			      <desc:var name="mark1" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark2" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="mark3" type="boolean" self="true">
			          A boolean used for directed graph traversal.
			      </desc:var>
			      <desc:var name="label" type="string"  self="true">
			         A label name used when unparsing directed graphs.
			      </desc:var>
			      <desc:var name="spaceBefore" type='enum["empty","space","line","lines","erase"]'
					self="true">
			         The amount of space present between the last non-blank character before 
				 this <@icode{xdom}/> item and the beginning of this xdom item.
			      </desc:var>
			      <desc:var name="spaceAfter" type='enum["empty","space","line","lines","erase"]'
					 self="true">
			         The amount of space present between the end of 
				 this <@icode{xdom}/> item and the next non-blank character.
			      </desc:var>
			      <desc:var name="val" self="true">
			      The contained value.
			      </desc:var>
			   </desc:type>
			</section:name>
		     </section:lettered>
		     <section:lettered name="Views" sort="fold">
			<section:name type="view" name="array">
			   <part name="Description">
			      <p>
			      View of <ref:name name="xdom:element"/> that allows unnamed
			      attributes to be treated as an array.
			      Array values are stored as follows.
			      </p>
			      <table:table>
				 <table:row>
				    <table:item>
				       <@icode{string}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:string}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{int}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:int}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{float}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:float}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       any other value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:value}/> node
				    </table:item>
				 </table:row>
			      </table:table>
			   </part>
			   <desc:view name="array">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?xdom:element}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Make">
				 <desc:varparam name="L">
				    a list of unnamed values or a list
				    or two parameters: the first of form <@icode{size=n}/> and
				    the second a unnamed value
				 </desc:varparam>
				 <desc:result type="array">
				    If a list of values is specified, the result is a new array constructed from the specified list of values.
				    For <@icode{array(size=n,v)}/>, the result is a new array of size <@icode{n}/>
				    with each element initialized to <@icode{v}/>.
				    The tag of the resulting <@icode{xdom:element}/> is <@icode{"array"}/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
			<section:name type="view" name="attr">
			   <part name="Description">
			      View of <ref:name name="xdom:element"/> that provides access
			      to the list of attributes.
			   </part>
			   <desc:view name="attr">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?xdom:element}/>.
				 </desc:result>
			      </desc:func>
			      <desc:const name="size" type="int" self="true">
				The number of attributes in the element.
			      </desc:const>
			      <desc:func name="sys:Subscript" self="true" kind="lhs/rhs">
				 <desc:param name="index" type="int">
				    The index of the attribute
				    to be selected.
				    For element <@icode{e}/> this
				    must be in the range <@icode{1..e.size#attr}/>.
				 </desc:param>
				 <desc:result type="xdom">
				    The <@icode{index}/>th attribute.
				 </desc:result>
			      </desc:func>
			      <desc:func name="insert" self="true">
				 <desc:param name="val" type="xdom">
				    a value to be inserted
				 </desc:param>
				 <desc:param name="pos" type="int" default="self.size#attr" optional="true">
				    this must be in the range <@icode{1..self.size#attr}/>.
				 </desc:param>
				 <desc:result type="void">
				    Inserts the new attribute value at the specified position.
				    If the position is <@icode{0}/>, the value is inserted
				    at the beginning of the attribute list.
				    Otherwise, the value is inserted after the <@icode{pos}/> attribute.
				 </desc:result>
			      </desc:func>
			      <desc:func name="delete" self="true">
				 <desc:param name="pos" type="int" optional="true">
				    this must be in the range <@icode{1..self.size#attr}/>.
				 </desc:param>
				 <desc:result type="void">
				    The attribute at the specified position is deleted from the
				    attribute list.
				 </desc:result>
			      </desc:func>
			      <desc:const name="all" self="true" type="func">
				 An iterator function that iterates over all the <@icode{xdom}/> attributes.
			      </desc:const>
			   </desc:view>
			</section:name>
			<section:name type="view" name="body">
			   <part name="Description">
			      View of <ref:name name="xdom:element"/> that provides access to
			      body <@icode{xdom}/> nodes.
			   </part>
			   <desc:view name="body">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?xdom:element}/>.
				 </desc:result>
			      </desc:func>
			      <desc:const name="size" type="int" self="true">
				The number of <@icode{xdom}/> nodes within the body.
			      </desc:const>
			      <desc:func name="sys:Subscript" self="true" kind="lhs/rhs">
				 <desc:param name="index" type="int">
				    The index of the parameter
				    to be selected.
				    For element <@icode{e}/> this
				    must be in the range <@icode{1..e.size#body}/>.
				 </desc:param>
				 <desc:result type="xdom">
				    The <@icode{index}/>th body node.
				 </desc:result>
			      </desc:func>
			      <desc:func name="insert" self="true">
				 <desc:param name="val" type="xdom">
				    a value to be inserted
				 </desc:param>
				 <desc:param name="pos" type="int" default="self.size#body" optional="true">
				    this must be in the range <@icode{1..self.size#body}/>.
				 </desc:param>
				 <desc:result type="void">
				    Inserts the new body node value at the specified position.
				    If the position is <@icode{0}/>, the value is inserted
				    at the beginning of the body list.
				    Otherwise, the value is inserted after the <@icode{pos}/> body node.
				 </desc:result>
			      </desc:func>
			      <desc:func name="delete" self="true">
				 <desc:param name="pos" type="int" optional="true">
				    this must be in the range <@icode{1..self.size#body}/>.
				 </desc:param>
				 <desc:result type="void">
				    The body node at the specified position is deleted from the
				    body list.
				 </desc:result>
			      </desc:func>
			      <desc:const name="all" self="true" type="func">
				 An iterator function that iterates over all the <@icode{xdom}/> body nodes.
			      </desc:const>
			   </desc:view>
			</section:name>
			<section:name type="view" name="bodyrec">
			   <part name="Description">
			      View of <ref:name name="xdom:element"/> that treats <@icode{xdom:element}/>s directly
			      within the body as a record.
			      The tag of those elements becomes the record element name.
			   </part>
			   <desc:view name="bodyrec">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?xdom:element}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Dot" self="true" kind="lhs/rhs" ext="true" param="false">
				 <desc:param name="name" type="string" kind="ext">
				    the tag of an element directly within the body to be selected.
				 </desc:param>
				 <desc:result>
				    The result is the body component with the specified tag.
				    On the rhs, if the body component does not exist the result is <@icode{null}/>.
				    On the lhs, if value being assigned is <@icode{null}/>, any element with
				    tag <@icode{name}/> is removed from the record.
				    On the lhs, if the named element does not exist, it is added.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
			<section:name type="view" name="boolean">
			   <part name="Description">
			      View of <ref:name name="string"/>.
			   </part>
			   <desc:view name="boolean">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{true}/> if <@icode{v}/> is
				    either <@icode{"true"}/> or <@icode{"false"}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:And">
				 <desc:param name="a" type="boolean">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="boolean">
				    second parameter.
				    If the value of <@icode{a}/> is <@icode{false}/>,
				    then the actual parameter expression for <@icode{b}/> is
				    not evaluated.
				 </desc:param>
				 <desc:result type="boolean">
				    The result is
				    the boolean and
				    of <@icode{a}/> and <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Or">
				 <desc:param name="a" type="boolean">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="boolean">
				    second parameter.
				    If the value of <@icode{a}/> is <@icode{true}/>,
				    then the actual parameter expression for <@icode{b}/> is
				    not evaluated.
				 </desc:param>
				 <desc:result type="boolean">
				    The result is
				    the boolean or
				    of <@icode{a}/> and <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Xor">
				 <desc:param name="a" type="boolean">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="boolean">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    The result is
				    is the boolean exclusive or
				    of <@icode{a}/> and <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Not">
				 <desc:param name="a" type="boolean">
				    first parameter
				 </desc:param>
				 <desc:result type="boolean">
				    The result is
				    is the boolean not
				    of <@icode{a}/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
			<section:name type="view" name="date">
			   <part name="Description">
			      <p>
			      View of <ref:name name="string"/> where the value represents a date and time.
			      Internally dates are represented as 64 bit integers that are
			      milliseconds after January 1, 1970 00:00:00 GMT.
			      Externally dates are strings such as the following example.
			      </p>
			      <@verb{"2006/09/28 10:22:34.881 PDT"}/>
			      <p>
				 A date string consist of the following numeric parts.
				 A numeric part may be omitted, but then all following numeric parts
				 must also be omitted.
				 If a numeric part is omitted the default value is the minimum permitted.
				 There is no default value for year.
			      </p>
			      <table:table>
				 <table:titlerow>
				    <table:item>
				       name
				    </table:item>
				    <table:item>
				       separator
				    </table:item>
				    <table:item>
				       value
				    </table:item>
				 </table:titlerow>  
				 <table:row>
				    <table:item>
				       year
				    </table:item>
				    <table:item>
				       <@verb{" "}/>
				    </table:item>
				    <table:item>
				       <@icode{"2006"}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       month
				    </table:item>
				    <table:item>
				       <@icode{"/"}/>
				    </table:item>
				    <table:item>
				       <@icode{"09"}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       day
				    </table:item>
				    <table:item>
				       <@icode{"/"}/>
				    </table:item>
				    <table:item>
				       <@icode{"28"}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       hour
				    </table:item>
				    <table:item>
				       <@icode{" "}/>
				    </table:item>
				    <table:item>
				       <@icode{"10"}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       minute
				    </table:item>
				    <table:item>
				       <@icode{":"}/>
				    </table:item>
				    <table:item>
				       <@icode{"22"}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       second
				    </table:item>
				    <table:item>
				       <@icode{":"}/>
				    </table:item>
				    <table:item>
				       <@icode{"34"}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       millisecond
				    </table:item>
				    <table:item>
				       <@icode{"."}/>
				    </table:item>
				    <table:item>
				       <@icode{"881"}/>
				    </table:item>
				 </table:row>
			      </table:table>
			      <p>
				 This can optionally be followed by a time zone.
				 The default for time zone is the local time zone.
			      </p>
			      <table:table>
				 <table:titlerow>
				    <table:item>
				       name
				    </table:item>
				    <table:item>
				       separator
				    </table:item>
				    <table:item>
				       value
				    </table:item>
				 </table:titlerow>  
				 <table:row>
				    <table:item>
				       timezone
				    </table:item>
				    <table:item>
				       <@icode{" "}/>
				    </table:item>
				    <table:item>
				       <@icode{"PDT"}/>
				    </table:item>
				 </table:row>
			      </table:table>
			      <p>
				 Examples of how to use the date view
				 can be found in the <ref:example name="date"/> example.
			      </p>
			   </part>
			   <desc:view name="date">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{true}/> if <@icode{val}/> is
				    a <@icode{string}/> that represents a date.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Make">
				 <desc:param name="val" optional="true" type="date">
				    a starting date value.
				 </desc:param>
				 <desc:nparam name="year" type="int" optional="true">
				    a year.
				 </desc:nparam>
				 <desc:nparam name="month" type="int" optional="true">
				    a month value (<@icode{1..12}/>).
				 </desc:nparam>
				 <desc:nparam name="day" type="int" optional="true">
				    a day (<@icode{1..31}/>).
				 </desc:nparam>
				 <desc:nparam name="hour" type="int" optional="true">
				    an hour (<@icode{0..23}/>).
				 </desc:nparam>
				 <desc:nparam name="minute" type="int" optional="true">
				    a minute (<@icode{0..59}/>).
				 </desc:nparam>
				 <desc:nparam name="second" type="int" optional="true">
				    a second (<@icode{0..59}/>).
				 </desc:nparam>
				 <desc:nparam name="millisecond" type="int" optional="true">
				    a millisecond value (<@icode{0..999}/>) 
				 </desc:nparam>
				 <desc:nparam name="timeZone" type="string" optional="true">
				    a timezone.
				 </desc:nparam>
				 <desc:result type="date">
				    <p>
				    If <@icode{val}/> is present, it forms the initial value.
				    If <@icode{val}/> is not present, <@icode{year}/> must
				    be present and the initial value is formed from that year
				    and default values for all other fields.
				    </p>
				    <p>
				       For each named parameter the initial value is modified
				       for that field to the specified value.
				       The overall result is the result of applying all
				       these modifications to the initial value.
				    </p>
				 </desc:result>
			      </desc:func>
			      <desc:func name="now">
				 <desc:result type="date">
				    The current date in the local timezone.
				 </desc:result>
			      </desc:func>
			      <desc:func name="gmt">
				 <desc:result type="date">
				    The current date in GMT (Greenwich Mean Time).
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Sub">
				 <desc:param name="a" type="date">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="date">
				    second parameter
				 </desc:param>
				 <desc:result type="int">
				   The result is the number of milliseconds that <@icode{a}/> is
				   after <@icode{b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="date">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="date">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> have the same date
				    value, then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="date">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="date">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> and <@icode{b}/> have the same date
				    value, then the result is <@icode{false}/>,
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Less">
				 <desc:param name="a" type="date">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="date">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is less than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:LessEq">
				 <desc:param name="a" type="date">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="date">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is less than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Greater">
				 <desc:param name="a" type="date">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="date">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is greater than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:GreaterEq">
				 <desc:param name="a" type="date">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="date">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    If <@icode{a}/> is greater than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:const name="year" type="int" self="true">
				 The year part of the date.
			      </desc:const>
			      <desc:const name="month" type="int" self="true">
				 The month part of the date (<@icode{1..12}/>.
			      </desc:const>
			      <desc:const name="day" type="int" self="true">
				 The day part of the date (<@icode{1..31}/>.
			      </desc:const>
			      <desc:const name="hour" type="int" self="true">
				 The hour part of the date (<@icode{0..23}/>.
			      </desc:const>
			      <desc:const name="minute" type="int" self="true">
				 The minute part of the date (<@icode{0..59}/>.
			      </desc:const>
			      <desc:const name="second" type="int" self="true">
				 The second part of the date (<@icode{0..59}/>.
			      </desc:const>
			      <desc:const name="millisecond" type="int" self="true">
				 The millisecond part of the date (<@icode{0..999}/>.
			      </desc:const>
			      <desc:const name="dayOfWeek" type="int" self="true">
				 The day of the week (<@icode{0..6}/>.
				 Sunday has value <@icode{0}/>.
			      </desc:const>
			      <desc:const name="dayOfYear" type="int" self="true">
				 The day of the year (<@icode{1..366}/>.
				 January 1 has value <@icode{1}/>.
			      </desc:const>
			      <desc:const name="timeZone" type="string" self="true">
				 The time zone part of the date.
			      </desc:const>
			      <desc:const name="timeZoneLong" type="string" self="true">
				 The long form of the time zone part of the date.
			      </desc:const>
			      <desc:const name="dst" type="boolean" self="true">
				 If the date is in daylight savings time the result is <@icode{true}/>.
			      </desc:const>
			      <desc:func name="add" self="true">
				 <desc:nparam name="year" type="int" optional="true">
				    a year delta.
				 </desc:nparam>
				 <desc:nparam name="month" type="int" optional="true">
				    a month delta.
				 </desc:nparam>
				 <desc:nparam name="day" type="int" optional="true">
				    a day delta.
				 </desc:nparam>
				 <desc:nparam name="hour" type="int" optional="true">
				    an hour delta.
				 </desc:nparam>
				 <desc:nparam name="minute" type="int" optional="true">
				    a minute delta.
				 </desc:nparam>
				 <desc:nparam name="second" type="int" optional="true">
				    a second delta.
				 </desc:nparam>
				 <desc:nparam name="millisecond" type="int" optional="true">
				    a millisecond delta.
				 </desc:nparam>
				 <desc:nparam name="timeZone" type="string" optional="true">
				    a new timezone.
				 </desc:nparam>
				 <desc:result type="date">
				    The result starts with the <@icode{self}/> data and then
				    applies any deltas or timezone changes and returns
				    that new date.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
			<section:name type="view" name="file">
			   <part name="Description">
			      <p>
				 View of <ref:name name="string"/> where the value is the path
				 name of a file or directory.
			      </p>
			      <p>
				 Examples of how to use the file view
				 can be found in the <ref:example name="file"/> example.
			      </p>
			   </part>
			   <desc:view name="file">
			      <desc:func name="exists" self="true">
				 <desc:result type="boolean">
				    Result is <@icode{true}/> if the file exists.
				 </desc:result>
			      </desc:func>
			      <desc:func name="create" self="true">
				 <desc:result type="boolean">
				    Creates the file if it does not exist.
				    Result is <@icode{true}/> if the file was created
				    (this is, it did not exist prior to this call).
				 </desc:result>
			      </desc:func>
			      <desc:func name="isDirectory" self="true">
				 <desc:result type="boolean">
				    Result is <@icode{true}/> if the file is a directory.
				 </desc:result>
			      </desc:func>
			      <desc:func name="read" self="true">
				 <desc:nparam name="charSet" type="string" default="ISO-8859-1" optional="true">
				    The <ref:numbered name="Character Set"/> to use for converting external
				    bytes to internal <@icode{string}/> characters.
				 </desc:nparam>
				 <desc:result type="string">
				    Returns the contents of the file.
				 </desc:result>
			      </desc:func>
			      <desc:func name="write" self="true">
				 <desc:param name="val" type="string">
				    a value to be written.
				 </desc:param>
				 <desc:nparam name="charSet" type="string" default="ISO-8859-1" optional="true">
				    The <ref:numbered name="Character Set"/> to use for converting
				    internal <@icode{string}/> characters to
				    external bytes.
				 </desc:nparam>
				 <desc:result type="void">
				    Replaces the contents of the file with <@icode{val}/>.
				    It creates the file if it does not exist.
				 </desc:result>
			      </desc:func>
			      <desc:func name="append" self="true">
				 <desc:param name="val" type="string">
				    a value to be appended.
				 </desc:param>
				 <desc:nparam name="charSet" type="string" default="ISO-8859-1" optional="true">
				    The <ref:numbered name="Character Set"/> to use for converting
				    internal <@icode{string}/> characters to
				    external bytes.
				 </desc:nparam>
				 <desc:result type="void">
				    Appends <@icode{val}/> to the end of the current contents of the file.
				    It creates the file if it does not exist.
				 </desc:result>
			      </desc:func>
			      <desc:func name="createDirectory" self="true">
				 <desc:result type="void">
				    Creates a new directory.
				 </desc:result>
			      </desc:func>
			      <desc:func name="delete" self="true">
				 <desc:result type="void">
				    Deletes the specified file or directory.
				 </desc:result>
			      </desc:func>
			      <desc:func name="rename" self="true">
				 <desc:param name="new" type="string">
				    a new name for the file.
				 </desc:param>
				 <desc:result type="void">
				    Renames the file to the <@icode{new}/> name.
				 </desc:result>
			      </desc:func>
			      <desc:const name="files" type="func" self="true">
				 Requires <@icode{self.isDirectory()}/>.
				 An iterator function that iterates over the names
				 of all files in a directory.
			      </desc:const>
			   </desc:view>
			</section:name>
			<section:name type="view" name="fold">
			   <part name="Description">
			      View of <ref:name name="string"/>.
			   </part>
			   <desc:view name="fold">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?string}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Make">
				 <desc:param name="s" type="string">
				    a string value
				 </desc:param>
				 <desc:result type="fold">
				    The resulting <@icode{string}/> will be the same as <@icode{s}/> except
				    all upper-case letters will have been folded to lower-case.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    After folding all upper case letters to lower case,
				    if <@icode{a}/> and <@icode{b}/> have the same size and
				    same characters, then the result is <@icode{true}/>, 
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    After folding all upper case letters to lower case,
				    if <@icode{a}/> and <@icode{b}/> have the same size and
				    same characters, then the result is <@icode{false}/>, 
				    else the result is <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Less">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    After folding all upper case letters to lower case,
				    if <@icode{a}/> is less than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:LessEq">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    After folding all upper case letters to lower case,
				    if <@icode{a}/> is less than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Greater">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    After folding all upper case letters to lower case,
				    if <@icode{a}/> is greater than <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:GreaterEq">
				 <desc:param name="a" type="string">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="string">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    After folding all upper case letters to lower case,
				    if <@icode{a}/> is greater than or equal to <@icode{b}/>,
				    then the result is <@icode{true}/>,
				    else the result is <@icode{false}/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
			<section:name type="view" name="list">
			   <part name="Description">
			      <p>
			      View of <ref:name name="xdom:element"/> for attribute lists.
			      List values are stored as follows.
			      </p>
			      <table:table>
				 <table:row>
				    <table:item>
				       <@icode{xdom}/> value
				    </table:item>
				    <table:item>
				       directly stored as is 
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{string}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:string}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{int}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:int}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{float}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:float}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       any other value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:value}/> node
				    </table:item>
				 </table:row>
			      </table:table>
			   </part>
			   <desc:view name="list">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?xdom:element}/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			      <desc:func name="sys:Make">
				 <desc:varparam name="L">
				    a list of named or unnamed values
				 </desc:varparam>
				 <desc:result type="list">
				    The result is a new list constructed from the specified list of values.
				    The tag of the resulting <@icode{xdom:element}/> is <@icode{"list"}/>.
				 </desc:result>
			      </desc:func>
			</section:name>
			<section:name type="view" name="rec">
			   <part name="Description">
			      <p>
			      View of <ref:name name="xdom:element"/> that allows named
			      attributes to be treated as a record.
			      Record values are stored as follows.
			      </p>
			      <table:table>
				 <table:row>
				    <table:item>
				       <@icode{string}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:string}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{int}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:int}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{float}/> value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:float}/> node
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       any other value
				    </table:item>
				    <table:item>
				       stored in a <@icode{xdom:value}/> node
				    </table:item>
				 </table:row>
			      </table:table>
			   </part>
			   <desc:view name="rec">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?xdom:element}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Make">
				 <desc:varparam name="L">
				    a list of named values
				 </desc:varparam>
				 <desc:result type="rec">
				    The result is a new record initialized to the specified named values.
				    The tag of the resulting <@icode{xdom:element}/> is <@icode{"rec"}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Dot" self="true" kind="lhs/rhs" ext="true" param="false">
				 <desc:param name="name" type="string" kind="ext">
				    the name of the record value to be selected
				 </desc:param>
				 <desc:result>
				    The result is the record component with the specified name.
				    On the rhs, if the named component does not exist the result is <@icode{null}/>.
				    On the lhs, if value being assigned is <@icode{null}/>, any component with
				    name <@icode{name}/> is removed from the record.
				    On the lhs, if the named component does not exist, it is added.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
			<section:name type="view" name="View">
			   <part name="Description">
			      Either <ref:name name="type"/> or <ref:name name="view"/>.
			   </part>
			   <desc:view name="View">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{v?type | v ? view}/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
			<section:name type="view" name="xdom">
			   <part name="Description">
			      View of all <@verb{"xdom"}/> types.
			   </part>
			   <desc:view name="xdom">
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="boolean">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{true}/> if <@icode{v}/> has type
				    <ref:name name="xdom:element"/>, <ref:name name="xdom:string"/>, <ref:name name="xdom:name"/>,
				    <ref:name name="xdom:call"/>, or <ref:name name="xdom:value"/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			</section:name>
		     </section:lettered>
		     <section:lettered name="Functions"  sort="fold">
			<section:name type="func" name="Add">
			   <part name="Description">
			      The expression
			      <@code{a+b}/>
			      is desugared to
			      <@code{Add(a,b)}/>
			   </part>
			   <desc:func name="Add">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:varparam name="L">
				 zero or more additional parameters
			      </desc:varparam>
			      <desc:result>
			         If the call has form <@icode{Add(a)}/>, then the result is
				 <@code{a}/>
				 else if the call has form <@icode{Add(a,b)}/>, then the result will be
				 <@code{Cover(Type[a],Type[b]).sys:Add(a,b)}/>
				 else the call will have form <@icode{Add(a,b,%M)}/> and the result will be
				 <@code{Add(Add(a,b),%M)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Sub">
			   <part name="Description">
			      The expression
			      <@code{a-b}/>
			      is desugared to
			      <@code{Sub(a,b)}/>.
			   </part>
			   <desc:func name="Sub">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result>
				 The result is  
				 <@code{Cover(Type[a],Type[b]).sys:Sub(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Mult">
			   <part name="Description">
			      The expression
			      <@code{a*b}/>
			      is desugared to
			      <@code{Mult(a,b)}/>
			   </part>
			   <desc:func name="Mult">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:varparam name="L">
				 zero or more additional parameters
			      </desc:varparam>
			      <desc:result>
			         If the call has form <@icode{Mult(a)}/>, then the result is
				 <@code{a}/>
				 else if the call has form <@icode{Mult(a,b)}/>, then the result will be
				 <@code{Cover(Type[a],Type[b]).sys:Mult(a,b)}/>
				 else the call will have form <@icode{Mult(a,b,%M)}/> and the result will be
				 <@code{Mult(Mult(a,b),%M)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Div">			   
			<part name="Description">
			   The expression
			   <@code{a/b}/>
			   is desugared to
			   <@code{Div(a,b)}/>.
			</part>
			<desc:func name="Div">
			   <desc:param name="a">
			      first parameter
			   </desc:param>
			   <desc:param name="b">
			      second parameter
			   </desc:param>
			   <desc:result>
			         The result is  
				 <@code{Cover(Type[a],Type[b]).sys:Div(a,b)}/>
			   </desc:result>
			</desc:func>
			</section:name>
			<section:name type="func" name="Rem">
			   <part name="Description">
			      The expression
			      <@code{a/+b}/>
			      is desugared to
			      <@code{Rem(a,b)}/>.
			   </part>
			   <desc:func name="Rem">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result>
			         The result is  
				 <@code{Cover(Type[a],Type[b]).sys:Rem(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Cat">
			   <part name="Description">
			      The expression
			      <@code{a++b}/>
			      is desugared to
			      <@code{Cat(a,b)}/>
			   </part>
			   <desc:func name="Cat">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:varparam name="L">
				 zero or more additional parameters
			      </desc:varparam>
			      <desc:result>
				 If the call has form <@icode{Cat(a)}/>, then the result is
				 <@code{string(a)}/>
				 else if the call has form <@icode{Cat(a,b)}/>, then the result will be
				 <@code{string.sys:Cat(a,b)}/>
				 else the call will have form <@icode{Cat(a,b,%M)}/> and the result will be
				 <@code{Cat(Cat(a,b),%M)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Minus">
			   <part name="Description">
			      The expression
			      <@code{-a}/>
			      is desugared to
			      <@code{Minus(a)}/>.
			   </part>
			   <desc:func name="Minus">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:result>
				 The result is  
				 <@code{Type[a].sys:Minus(a)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Not">
			   <part name="Description">
			      The expression
			      <@code{! a}/>
			      is desugared to
			      <@code{Not(a)}/>
			   </part>
			   <desc:func name="Not">
			      <desc:param name="a" type="boolean">
				 first parameter
			      </desc:param>
			      <desc:result type="boolean">
				 The result is
				 <@code{boolean.sys:Not(a)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Percent">
			   <part name="Description">
			      The expression
			      <@code{% L}/>
			      is desugared to
			      <@code{Percent(L)}/>
			   </part>
			   <desc:func name="Percent">
			      <desc:param name="L" type="xdom:element">
				 first parameter.
			      </desc:param>
			      <desc:result type="boolean">
				 The percent function has special semantics for dealing
				 with variable length parameter list.
				 A function that takes a variable number of parameters
				 has a single formal parameter whose name is preceded with
				 a <@verb{"%"}/> prefix operator.
				 When an actual parameter has the form <@icode{%L}/>,
				 it is replaced by a sequence of positional and named
				 parameters that come from the attributes of <@icode{L}/>.
			      </desc:result>
			   </desc:func>
			   <part name="Examples">
			      <@code{
			       @x:func bar(%L) {
			           @x:for v:= L {
			             v; ";"
				   }
			       }	
			       @x:func foo(%L) {
			          bar(%L,"abc");
			       }
			       foo(1,2,3);
			       // result is: 1;2;3;abc;
			      }/>
			   </part>
			</section:name>
			<section:name type="func" name="XDOMValue">
			   <part name="Description">
			      <p>
			      The expression
			      <@code{** a}/>
			      is desugared to
			      <@code{XDOMValue(a)}/>
			      </p>
			      <p>
				 The <@icode{Unparse}/> function uses the <ref:preop name="**"/> prefix operator
				 to represent <@icode{xdom:element}/> node value that are for internal
				 use only.  This output can be useful in debugging.
			      </p>
			   </part>
			   <desc:func name="XDOMValue">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:result>
				 It is an error to execute a call to <@icode{XDOMValue}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Assert">
			   <part name="Description">
			      The expression
			      <@code{~ a}/>
			      is desugared to
			      <@code{Assert(a)}/>
			   </part>
			   <desc:func name="Assert">
			      <desc:param name="a" type="boolean">
				 first parameter
			      </desc:param>
			      <desc:result type="void">
				 It is an error if the value of <@icode{a}/> is <@icode{false}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Equal">
			   <part name="Description">
			      The expression
			      <@code{a = b}/>
			      is desugared to
			      <@code{Equal(a,b)}/>
			   </part>
			   <desc:func name="Equal">
			      <desc:param name="a">
				 a <ref:nt name="id"/> that names a value.
			      </desc:param>
			      <desc:param name="b">
				 the value to be named
			      </desc:param>
			      <desc:result type="void">
				 The <@icode{Equal}/> function has special assignment semantics.
				 Its use is restricted to certain special contexts.
				 First it can be used for named parameters.
				 Second it is used for named <@icode{xdom:element}/> attributes.
			      </desc:result>
			   </desc:func>
			   <part name="Examples">
			      <@code{
			      Unparse(t,html=true);
			      <a href="foo.html">foo</a>
			      }/>
			   </part>
			</section:name>
			<section:name type="func" name="Assign">
			   <part name="Description">
			      The expression
			      <@code{a := b}/>
			      is desugared to
			      <@code{Assign(a,b)}/>
			   </part>
			   <desc:func name="Assign">
			      <desc:param name="a">
				 the target of the assignment.
			      </desc:param>
			      <desc:param name="b">
				 the value to be assigned.
			      </desc:param>
			      <desc:result type="void">
				 The <@icode{Assign}/> function has special assignment semantics.
				 The value of <@icode{b}/> is assigned to the location
				 specified by <@icode{a}/>.
				 The first parameter <@icode{a}/> can be either a variable
				 or a function call to a function that is a LHS/RHS function
				 pair. For the function pair, the LHS function is called after adding
				 the value of <@icode{b}/> as an extra actual parameter.
				 It is also common to for <@icode{a}/> to be a sugared form
				 of LHS/RHS function call such as a subscripting operation
				 or a dot qualification operation.
			      </desc:result>
			   </desc:func>
			   <part name="Examples">
			      <@code{
			      @x:var a := 3;
			      @x:var b := rec();
			      a := 7; // assigns 7 to a
			      b.x#rec := 5; // desugared to b.sys:Dot#rec["x"](5)
			      }/>
			   </part>
			</section:name>
			<section:name type="func" name="Or">
			   <part name="Description">
			      The expression
			      <@code{a|b}/>
			      is desugared to
			      <@code{Or(a,b)}/>
			   </part>
			   <desc:func name="Or">
			      <desc:param name="a" type="boolean">
				 first parameter
			      </desc:param>
			      <desc:varparam name="L">
				 zero or more additional <@icode{boolean}/> parameters
			      </desc:varparam>
			      <desc:result type="boolean">
				 If the call has form <@icode{Or(a)}/>, then the result is
				 <@code{a}/>
				 else if the call has form <@icode{Or(a,b)}/>, then the result will be
				 <@code{boolean.sys:Or(a,b)}/>
				 else the call will have form <@icode{Or(a,b,%M)}/> and the result will be
				 <@code{Or(Or(a,b),%M)}/>
				 If the result of evaluating <@icode{a}/> is <@icode{true}/>, then no other parameters
				 are evaluated.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Xor">
			   <part name="Description">
			      The expression
			      <@code{a^b}/>
			      is desugared to
			      <@code{Xor(a,b)}/>.
			   </part>
			   <desc:func name="Xor">
			      <desc:param name="a" type="boolean">
				 first parameter
			      </desc:param>
			      <desc:param name="b" type="boolean">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
			         The result is  
				 <@code{boolean.sys:Xor(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="And">
			   <part name="Description">
			      The expression
			      <@code{a&b}/>
			      is desugared to
			      <@code{And(a,b)}/>
			   </part>
			   <desc:func name="And">
			      <desc:param name="a" type="boolean">
				 first parameter
			      </desc:param>
			      <desc:varparam name="L">
				 zero or more additional <@icode{boolean}/> parameters
			      </desc:varparam>
			      <desc:result type="boolean">
			         If the call has form <@icode{And(a)}/>, then the result is
				 <@code{a}/>
				 else if the call has form <@icode{And(a,b)}/>, then the result will be
				 <@code{boolean.sys:And(a,b)}/>
				 else the call will have form <@icode{And(a,b,%M)}/> and the result will be
				 <@code{And(And(a,b),%M)}/>
				 If the result of evaluating <@icode{a}/> is <@icode{false}/>, then no other parameters
				 are evaluated.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Eq">
			   <part name="Description">
			      The expression
			      <@code{a==b}/>
			      is desugared to
			      <@code{Eq(a,b)}/>.
			   </part>
			   <desc:func name="Eq">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
			         If <@icode{Cover(Type[a],Type[b])}/> is <@icode{null}/>, then the result is
				 <@code{false}/>
				 else the result is
				 <@code{Cover(Type[a],Type[b]).sys:Eq(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Ne">
			   <part name="Description">
			      The expression
			      <@code{a!=b}/>
			      invokes
			      <@code{Ne(a,b)}/>.
			   </part>
			   <desc:func name="Ne">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
			         If <@icode{Cover(Type[a],Type[b])}/> is <@icode{null}/>, then the result is
				 <@code{true}/>
				 else the result is
				 <@code{Cover(Type[a],Type[b]).sys:Ne(a,b)}/>
			      </desc:result>
			   </desc:func>
			   
			</section:name>
			<section:name type="func" name="Less">
			   <part name="Description">
			      The expression
			      <@code{a<b}/>
			      is desugared to
			      <@code{Ls(a,b)}/>.
			   </part>
			   <desc:func name="Less">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
			         If <@icode{Cover(Type[a],Type[b])}/> is <@icode{null}/>, then the result is
				 <@code{false}/>
				 else the result is
				 <@code{Cover(Type[a],Type[b]).sys:Less(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="LessEq">
			   <part name="Description">
			      The expression
			      <@code{a<=b}/>
			      is desugared to
			      <@code{Less(a,b)}/>.
			   </part>
			   <desc:func name="LessEq">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
			         If <@icode{Cover(Type[a],Type[b])}/> is <@icode{null}/>, then the result is
				 <@code{false}/>
				 else the result is
				 <@code{Cover(Type[a],Type[b]).sys:LessEq(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Greater">
			   <part name="Description">
			      The expression
			      <@code{a>b}/>
			      is desugared to
			      <@code{Greater(a,b)}/>.
			   </part>
			   <desc:func name="Greater">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
			         If <@icode{Cover(Type[a],Type[b])}/> is <@icode{null}/>, then the result is
				 <@code{false}/>
				 else the result is
				 <@code{Cover(Type[a],Type[b]).sys:Greater(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="GreaterEq">
			   <part name="Description">
			      The expression
			      <@code{a>=b}/>
			      is desugared to
			      <@code{GreaterEq(a,b)}/>.
			   </part>
			   <desc:func name="GreaterEq">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
			         If <@icode{Cover(Type[a],Type[b])}/> is <@icode{null}/>, then the result is
				 <@code{false}/>
				 else the result is
				 <@code{Cover(Type[a],Type[b]).sys:GreaterEq(a,b)}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Range">
			   <part name="Description">
			      The expression
			      <@code{a..b}/>
			      is desugared to
			      <@code{Range(a,b)}/>
			      which in turn invokes
			      <@code{Range[a,b]}/>
			      which is an iterator function that iterates over
			      all <@icode{int}/> values starting with <@icode{a}/> and ending with <@icode{b}/>.
			   </part>
			   <desc:func name="Range">
			      <desc:param name="first" type="int">
				 first value.
			      </desc:param>
			      <desc:param name="last" type="int">
				 last value.
			      </desc:param>
			      <desc:result>
				 The result is the iterator <@icode{Range[first,last]}/>.
			      </desc:result>
			   </desc:func>
			   <desc:func name="Range" ext="true">
			      <desc:param name="first" type="int" kind="ext">
				 first value.
			      </desc:param>
			      <desc:param name="last" type="int" kind="ext">
				 last value.
			      </desc:param>
			      <desc:param name="act">
				 the iterator body function.
				 It takes a single parameter of type <@icode{int}/>.
			      </desc:param>
			      <desc:result>
				 This is an iterator function that iterates
				 over all <@icode{int}/> values between <@icode{a}/> and <@icode{b}/> inclusive.
				 If <@icode{b < a}/>, then the iterator body <@icode{act}/> is not executed.
			      </desc:result>
			   </desc:func>
			   <part name="Examples">
			      <@code{
			      @x:var result := 1;
			      @x:for i := 1..10 {
			          result := result * i;
			      }
			      }/>
			   </part>
			</section:name>
			<section:name type="func" name="Tilde">
			   <part name="Description">
			      The expression
			      <@code{a~b}/>
			      is desugared to
			      <@code{Tilde(a,b)}/>.
			   </part>
			   <desc:func name="Tilde">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b" type="View">
				 second parameter
			      </desc:param>
			      <desc:result>
				 It is an error if <@icode{! a?b}/>.
				 The result will be the value of <@icode{a}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Question">
			   <part name="Description">
			      The expression
			      <@code{a?b}/>
			      is desugared to
			      <@code{Question(a,b)}/>.
			   </part>
			   <desc:func name="Question">
			      <desc:param name="a">
				 first parameter
			      </desc:param>
			      <desc:param name="b" type="View">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
				 If the value of <@icode{a}/> is within the type or view
				 specified by <@icode{b}/> the result is <@icode{true}/>.
				 Otherwise the result is <@icode{false}/>.
				 If <@icode{b}/> is a view then this result found by
				 calling <@icode{b.sys:Is(a)}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Cover">
			   <part name="Description">
			      <p>
				 The <@icode{Cover}/> function is used to determine
				 which type to use when an infix operation contains
				 operands of different types.  For example,
				 for the expression
				 <@code{2 + 3.7}/>
				 a call to <@icode{Cover(int,float)}/> returns <@icode{float}/> meaning
				 that
				 <@code{float.sys:Add(2,3.7)}/>
				 should be called.
			      </p>
			      <p>
				 Note that a <@icode{null}/> result from <@icode{Cover}/> will cause an error when
				 called during processing most infix operators meaning that
				 the particular combination of types is not supported for that operator.
			      </p>
			   </part>
			   <desc:func name="Cover">
			      <desc:param name="a" type="type">
				 first parameter
			      </desc:param>
			      <desc:param name="b" type="type">
				 second parameter
			      </desc:param>
			      <desc:result type="boolean">
				 If <@icode{a}/> and <@icode{b}/> have the same type
				 then the result is
				 <@code{a}/>
				 else if <@icode{HasDot(a,"sys:Cover")}/> and <@icode{a.sys:Cover(b)}/> returns <@icode{true}/>,
				 then the result is
				 <@code{a}/>
				 else if <@icode{HasDot(b,"sys:Cover")}/> and <@icode{b.sys:Cover(a)}/> returns <@icode{true}/>,
				 then the result is
				 <@code{b}/>
				 else the result is
				 <@code{null}/>
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="HasDot">
			   <part name="Description">
			      The <@icode{HasDot}/> function serves as a testable precondition,
			      for the <@icode{Dot}/> function.
			   </part>
			   <desc:func name="HasDot" ext="optional">
			      <desc:varparam name="L" kind="ext">
				 name parameters
			      </desc:varparam>
			      <desc:param name="base">
				 value to be qualified
			      </desc:param>
			      <desc:param name="n" type="string">
				 component name
			      </desc:param>
			      <desc:param name="v" type="View" optional="true">
				 type or view to use
			      </desc:param>
			      <desc:result type="boolean">
				 If a similar call to <@icode{Dot}/> would succeed then
				 the result of <@icode{HasDot}/> should be
				 <@code{true}/>
				 else the result should be
				 <@code{false}/>
			      </desc:result>
			   </desc:func>
			   <part name="Examples">
			      <@code{
			       @type T {
			          @x:var v:=rec(b=3,a=7);
			          @x:func sys:HasDot[name],visible { name?enum["a","b"] }
			          @x:func sys:Dot[name],visible { Dot(v,name,rec) }
			       }
			       ~ HasDot(T,"a");
			       ~ HasDot(T,"b");
			       ~ ! HasDot(T,"c");       // no c component
			       ~ HasDot[](T,"sys:Dot"); // no matching of extensions occurs
			       ~ ! HasDot(T,"sys:Dot"); // no def of sys:Dot without an extension
			       ~ ! HasDot(T,v);	        // v is not visible
			       }/>
			       
			   </part>
			</section:name>
			<section:name type="func" name="Dot">
			   <desc:func name="Dot" ext="optional">
			      <desc:varparam name="L" kind="ext">
				 name parameters
			      </desc:varparam>
			      <desc:param name="base">
				 value to be qualified
			      </desc:param>
			      <desc:param name="n" type="string">
				 component name
			      </desc:param>
			      <desc:param name="v" type="View" optional="true">
				 type or view to use
			      </desc:param>
			      <desc:result>
			      </desc:result>
			   </desc:func>
			   First the type or view, <@icode{v1}/>, to use must be determined.
			   <list:unordered>
			      <list:item>
				 If the <@icode{v}/> parameter is present,
				 then let <@icode{v1}/> be <@icode{v}/>.
			      </list:item>
			      <list:item>
				 Otherwise, if <@icode{base?View}/>,
				 then let <@icode{v1}/> be <@icode{base}/>.
			      </list:item>
			      <list:item>
				 Otherwise,
				 let <@icode{v1}/> be <@icode{Type[base]}/>.
			      </list:item>
			   </list:unordered>
			   There are two major cases.
			   <list:unordered>
			      <list:item name="View">
				 If <@icode{base?View}/> then
				 <list:unordered>
				    <list:item>
				       If there is a visible item with name <@icode{n[L]}/>
				       within the top level of the <ref:tag name="x:type"/>
				       or <ref:tag name="x:view"/> tag for <@icode{v1}/>, then that item
				       is the result.
				    </list:item>
				    <list:item>
				       Otherwise the result is
				       <@code{base.sys:Dot[n,L]#v1}/>
				    </list:item>
				 </list:unordered>
			      </list:item>
			      <list:item name="Object">
				 Otherwise, 
				 <list:unordered>
				    <list:item>
				       If there is a visible item with name <@icode{n[L]}/>
				       within the top level of the <ref:tag name="x:self"/>
				       tag for <@icode{v1}/>, then that item
				       is the result (with <@icode{self}/> set to <@icode{base}/>).
				    </list:item>
				    <list:item>
				       Otherwise the result is
				       <@code{base.sys:Dot[n,L]#v1}/>
				    </list:item>
				 </list:unordered>
			      </list:item>
			   </list:unordered>
			   <part name="Examples">
			      <p>
			      Suppose <@icode{T}/> is a type, <@icode{V}/> is a view of that type, and <@icode{X}/> is
			      an object with that type.
			      <table:table>
				 <table:row>
				    <table:item>
				       <@icode{T.m1(a,b)}/>
				    </table:item>
				    <table:item>
				       <@icode{Dot(T,"m1")(a,b)}/>
				    </table:item>
				    <table:item>
				       invokes a type method of <@icode{T}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{X.m2(a,b)}/>
				    </table:item>
				    <table:item>
				       <@icode{Dot(X,"m2")(a,b)}/>
				    </table:item>
				    <table:item>
				       invokes a self method of <@icode{T}/> (with <@icode{~ self == base}/>)
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{V.m3(a,b)}/>
				    </table:item>
				    <table:item>
				       <@icode{Dot(V,"m3")(a,b)}/>
				    </table:item>
				    <table:item>
				       invokes a view method of <@icode{V}/>
				    </table:item>
				 </table:row>
				 <table:row>
				    <table:item>
				       <@icode{X.m4#V(a,b)}/>
				    </table:item>
				    <table:item>
				       <@icode{Dot(X,"m4",V)(a,b)}/>
				    </table:item>
				    <table:item>
				       invokes a self method of <@icode{V}/> (with <@icode{~ self == base}/>)
				    </table:item>
				 </table:row>
			      </table:table>
			      </p>
			      <p>
			      <p>
				 Suppose <@icode{X}/> has type <@icode{xdom:element}/>
				 for the tag <@icode{<foo a="3"><b c="x"/></foo>}/>, then
				 <table:table>
				    <table:row>
				       <table:item>
					  <@icode{X.tag}/>
				       </table:item>
				       <table:item>
					  the element tag (<@icode{"foo"}/>)
				       </table:item>
				    </table:row>
				    <table:row>
				       <table:item>
					  <@icode{X.a#rec}/>
				       </table:item>
				       <table:item>
					  a record component (<@icode{"3"}/>)
				       </table:item>
				    </table:row>
				    <table:row>
				       <table:item>
					  <@icode{X.b#bodyrec}/>
				       </table:item>
				       <table:item>
					  a body record component (<@icode{<b c="x"/>}/>)
				       </table:item>
				    </table:row>
				 </table:table>
			      </p>
			      To write a type method to handle <@icode{T.xx}/> and
			      self method to handle <@icode{X.yy}/>
			      <@code{@x:type T {
			          @x:var x := 99;
			          @x:func sys:Dot[a~enum["xx"]],visible { x+x }
			       }@x:self {
			          @x:var y := 50;
			          @x:func sys:Dot[b~enum["yy"]],visible { y-1 }
			       }}/>
			      </p>
			   </part>
			   
			</section:name>
			<section:name type="func" name="Log">
			   <part name="Description">
			      Used to write an informational log message.
			   </part>			   
			   <desc:func name="Log">
			      <desc:param name="msg" type="string">
				 the message.
			      </desc:param>
			      <desc:nparam name="where" type="xdom" optional="true">
				 place to report message.
				 If not present, the message is reported on
				 the call to Log itself.
			      </desc:nparam>
			      <desc:result type="void">
				 Adds the message to the error log.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Warn">
			   <part name="Description">
			      Used to write an warning log message.
			   </part>			   
			   <desc:func name="Warn">
			      <desc:param name="msg" type="string">
				 the message.
			      </desc:param>
			      <desc:nparam name="where" type="xdom" optional="true">
				 place to report warning.
				 If not present, the warning is reported on
				 the call to Warn itself.
			      </desc:nparam>
			      <desc:result type="void">
				 Adds the message to the error log.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Error">
			   <part name="Description">
			      Used to write an error log message.
			   </part>			   
			   <desc:func name="Error">
			      <desc:param name="msg" type="string">
				 the message.
			      </desc:param>
			      <desc:nparam name="where" type="xdom" optional="true">
				 place to report error.
				 If not present, the error is reported on
				 the call to Error itself.
			      </desc:nparam>
			      <desc:result type="void">
				 Adds the message to the error log.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Parse">
			   <part name="Description">
			      This function is the build-in &xact; parser.
			      It will parse &xact; scripts and
			      the subset of XML supported by &xact; syntax.
			   </part>
			   <desc:func name="Parse">
			      <desc:param name="text" type="string">
				 input text to be parsed.
				 This parameter is a <ref:numbered name="Stream Sink"/>.
				 When optimization is on, the implementation will
				 in some cases start up a separate thread
				 to evaluate this parameter.
			      </desc:param>
			      <desc:nparam name="handler" optional="true">
				 parse event handler object.
			      </desc:nparam>
			      <desc:nparam name="fileName" type="string" optional="true">
				 if the <@icode{text}/> parameter is a file, the name of that file.
				 This is used for error reporting.
				 Only one of <@icode{fileName}/>, <@icode{scriptName}/>, and
				 <@icode{name}/> may be present.
			      </desc:nparam>
			      <desc:nparam name="scriptName" type="string" optional="true">
				 if the <@icode{text}/> parameter is a script file, the script name of
				 that script.
				 This is used for error reporting.
				 Only one of <@icode{fileName}/>, <@icode{scriptName}/>, and
				 <@icode{name}/> may be present.
			      </desc:nparam>
			      <desc:nparam name="name" type="string" optional="true">
				 a short description of the text being parsed.
				 This is used for error reporting.
				 Only one of <@icode{fileName}/>, <@icode{scriptName}/>, and
				 <@icode{name}/> may be present.
			      </desc:nparam>
			      <desc:result type="xdom">
				 Returns the resulting parse tree.
			      </desc:result>
			   </desc:func>
			   <p>
			      If the <@icode{handler}/> is specified it may have any
			      of the following operations.
			   </p>
			   <desc:type>
			   <desc:func name="start" self="true">
			      <desc:result type="void">
				 Called before parsing starts.
			      </desc:result>
			   </desc:func>
			   <desc:func name="end" self="true">
			      <desc:result type="void">
			      Called after parsing is done.
			      </desc:result>
			   </desc:func>
			   <desc:func name="startElement" self="true">
			      <desc:param name="elem" type="xdom:element">
				 element.
			      </desc:param>
			      <desc:param name="hasAttr" type="boolean">
				 has value <@icode{true}/> if the element has any attributes.
			      </desc:param>
			      <desc:result type="void">
			      Called at the start of an XML element / &xact; command.
			      </desc:result>
			   </desc:func>
			   <desc:func name="endElement" self="true">
			      <desc:param name="elem" type="xdom:element">
				 element.
			      </desc:param>
			      <desc:result type="void">
			      Called at the end of an XML element / &xact; command.
			      </desc:result>
			   </desc:func>
			   <desc:func name="startBody" self="true">
			      <desc:param name="elem" type="xdom:element">
				  element.
			      </desc:param>
			      <desc:param name="hasBody" type="boolean">
				 has value <@icode{true}/> if the element
				 body is not empty.
			      </desc:param>
			      <desc:result type="void">
			      Called at the start of the body of an XML element / &xact; command.
			      </desc:result>
			   </desc:func>
			   <desc:func name="endAttr" self="true">
			      <desc:param name="attr" type="xdom:element">
				  element that contains the attribute.
			      </desc:param>
			      <desc:param name="attr" type="xdom">
				 attribute.
			      </desc:param>
			      <desc:result type="TypeOr[void,xdom]">
			      Called at the end of an attribute.
			      A result of <@icode{null}/> discards the attribute.
			      Returning <@icode{attr}/> keeps the attribute.
			      Returning any other value substitutes that value for the attribute.
			      </desc:result>
			   </desc:func>
			   <desc:func name="endChild" self="true">
			      <desc:param name="elem" type="xdom:element">
				 element that contains the child
			      </desc:param>
			      <desc:param name="attr" type="xdom:element">
				 child element.
			      </desc:param>
			      <desc:result type="TypeOr[void,xdom]">
			      Called at the end of a child element.
			      A result of <@icode{null}/> discards the child.
			      Returning <@icode{attr}/> keeps the child.
			      Returning any other value substitutes that value for the child.
			      </desc:result>
			   </desc:func>
			   </desc:type>
			</section:name>
			<section:name type="func" name="Bind">
			   <p>
			      This function calls the interpreter bind1 and bind2
			      passes on a specified tree.
			      Bind1 processes scopes and name definitions.
			      Bind2 processes name uses.
			   </p>
			   <desc:func name="Bind">
			      <desc:param name="tree" type="xdom">
				 the tree to be bound.
			      </desc:param>
			      <desc:param name="language" default="lang:xact" optional="true">
				 The language to be used for binding.
			      </desc:param>
			      <desc:result type="void">
				 Scopes, name definitions, and name uses are
				 bound on the specified tree using the specified
				 language.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Exec">
			   <p>
			      This function calls the interpreter exec
			      pass on a specified tree.
			      This pass executes the tree.
			   </p>
			   <desc:func name="Bind">
			      <desc:param name="tree" type="xdom">
				 the tree to be executed.
			      </desc:param>
			      <desc:param name="language" default="lang:xact" optional="true">
				 The language to be used for execution.
			      </desc:param>
			      <desc:result>
				 The specified tree is executed using the specified
				 language. The result of calling <@icode{Exec}/> will
				 be the result of that tree execution.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Comment">
			   <part name="Description">
			      <p>
			      The <ref:nt name="compound cmd"/> comment form
			      </p>
			      <@verb{"// foo"}/>
			      <p>
			      is desugared to
			      </p>
			      <@code{Comment(" foo")}/>
			   </part>			   
			   <desc:func name="Comment">
			      <desc:param name="txt" type="string">
				 the comment text.
			      </desc:param>
			      <desc:result type="void">
				 Executing a call to <@icode{Comment}/> has no effect.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Type">
			   <part name="Description">
			      Finds the type of a value.
			   </part>			   
			   <desc:func name="Type" ext="true" param="false">
			      <desc:param name="val" type="string" kind="ext">
				 a value.
			      </desc:param>
			      <desc:result type="type">
				 Returns the type of <@icode{val}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="URLParseQuery">
			   <part name="Description">
			      This function is the inverse of <@icode{URLUnparseQuery}/>.
			   </part>			   
			   <desc:func name="XMLUnparseQuery">
			      <desc:param name="string" type="xdom:call">
				 encoded information passed via a URL.
			      </desc:param>
			      <desc:result type="xdom:call">
				 The decoded parse tree for the information.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="URLUnparseQuery">
			   <part name="Description">
			      This function is use to encode information that is
			      to be passed from one script to another via a URL.
			      It is called by the library <@icode{A}/> and <@icode{FORM}/> functions.
			   </part>			   
			   <desc:func name="XMLUnparseQuery">
			      <desc:param name="tree" type="xdom:call">
				 The information to be passed.
				 The call should have name <@icode{query}/> and
				 one or more parameters.
				 The first parameter is typically another <@icode{xdom:call}/> that
				 gives the script to be called and its parameters (both positional and named).
				 Parameters value must be strings.
				 The remaining parameters are trees for expressions of the
				 form <@icode{name=val}/> where <@icode{val}/> is a string.
				 The called scripts can access these values via <@icode{passed}/>.
			      </desc:param>
			      <desc:result type="string">
				 The encoded version of <@icode{tree}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="Chars">
			   <part name="Description">
			      The <@icode{Chars}/> iterator iterates
			      over each character of a <@icode{string}/>.
			   </part>
			   <desc:func name="Chars" ext="true">
			      <desc:param name="str" type="string" kind="ext">
				 a string to be iterated over.
				 This parameter is a <ref:numbered name="Stream Sink"/>.
				 When optimization is on, the implementation will
				 in some cases start up a separate thread
				 to evaluate this parameter.
			      </desc:param>
			      <desc:param name="act">
				 the iterator body function.
				 It takes a single parameter of type <@icode{int}/> which
				 is a character code.
			      </desc:param>
			      <desc:result>
				 This is an iterator function that iterates
				 over all character of a string.
			      </desc:result>
			   </desc:func>
			   <part name="Examples">
			      <@code{
			      @x:for ch := Chars["abc"] {
			         f(ch);
			      }
			      }/>
			   </part>
			</section:name>
			<section:name type="func" name="Lines">
			   <part name="Description">
			      The <@icode{Lines}/> iterator iterates
			      over each line of <@icode{string}/>.
			      Lines are separated by <@icode{eol}/> characters.
			   </part>
			   <desc:func name="Line" ext="true">
			      <desc:param name="str" type="string" kind="ext">
				 a string to be iterated over.
				 This parameter is a <ref:numbered name="Stream Sink"/>.
				 When optimization is on, the implementation will
				 in some cases start up a separate thread
				 to evaluate this parameter.
			      </desc:param>
			      <desc:param name="act">
				 the iterator body function.
				 It takes a single parameter of type <@icode{string}/>
				 which is a single line of the string.
			      </desc:param>
			      <desc:result>
				 This is an iterator function that iterates
				 over all lines of a string.
			      </desc:result>
			   </desc:func>
			   <part name="Examples">
			      <@code{
			      @x:for line := Lines[fname.read#file()] {
			         g(line);
			      }
			      }/>
			   </part>
			</section:name>
			<section:name type="func" name="walk:define">
			   <part name="Description">
			      This special function should only be called
			      during the bind1 pass within <ref:numbered name="Language Definition"/> types.
			      It defines a a name in a scope.
			      The <ref:example name="DocLang"/> example shows
			      a sample use.
			   </part>
			   <desc:func name="walk:define">
			      <desc:param name="name" type="xdom:name">
				 the name to be defined.
			      </desc:param>
			      <desc:param name="scope" type="xdom:element">
				 the scope where the name is to be defined.
			      </desc:param>
			      <desc:result type="null">
				 The name <@icode{name}/> is defined
				 in scope <@icode{scope}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="walk:body">
			   <part name="Description">
			      This special function should only be called
			      within <ref:numbered name="Language Definition"/> types.
			      It walks the body of <@icode{xdom:element}/> tree node.
			      The <ref:example name="DocLang"/> example shows
			      a sample use.
			   </part>
			   <desc:func name="walk:body">
			      <desc:param name="elem" type="xdom:element">
				 the element whose body is to be walked.
			      </desc:param>
			      <desc:param name="lang">
				 The language object to be used to process the body.
			      </desc:param>
			      <desc:result>
				 The pass result.
				 This will be <@icode{null}/> for bind1 and bind2
				 and the value produced by evaluating the body
				 in exec.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="walk:assign">
			   <part name="Description">
			      This special function should only be called
			      during the exec pass within <ref:numbered name="Language Definition"/> types.
			      It assigns a value to a defined name.
			      The <ref:example name="DocLang"/> example shows
			      a sample use.
			   </part>
			   <desc:func name="walk:assign">
			      <desc:param name="name" type="xdom:name">
				 the name that is the target of assignment.
			      </desc:param>
			      <desc:param name="val">
				 a value to be assigned.
			      </desc:param>
			      <desc:result type="null">
				 The value of name <@icode{name}/> is changed
				 to have value <@icode{val}/>.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="walk:exp">
			   <part name="Description">
			      This special function should only be called
			      within <ref:numbered name="Language Definition"/> types.
			      It walks a subtree of type <@icode{xdom}/> which
			      is not a <@icode{xdom:element}/>.
			      The <ref:example name="DocLang"/> example shows
			      a sample use.
			   </part>
			   <desc:func name="walk:exp">
			      <desc:param name="exp" type="xdom">
				 the subtree to be walked.
				 Must not have type <@icode{xdom:element}/>.
			      </desc:param>
			      <desc:result>
				 The pass result.
				 This will be <@icode{null}/> for bind1 and bind2
				 and the value produced by evaluating the expression
				 in exec.
			      </desc:result>
			   </desc:func>
			</section:name>
			<section:name type="func" name="walk:other">
			   <part name="Description">
			      This special function should only be called
			      within <ref:numbered name="Language Definition"/> types.
			      Its assigns processing to some other language type.
			      The <ref:example name="DocLang"/> example shows
			      a sample use.
			   </part>
			   <desc:func name="walk:other">
			      <desc:param name="lang">
				 the language object that should take over processing.
			      </desc:param>
			      <desc:param name="space" type="string">
				 the name space of the command to be processed.
				 This is usually the same as <@icode{elem.space}/>,
				 but may be different during renaming.
			      </desc:param>
			      <desc:param name="base" type="string">
				 the name base of the command to be processed.
				 This is usually the same as <@icode{elem.base}/>,
				 but may be different during renaming.
			      </desc:param>
			      <desc:param name="elem" type="xdom">
				 the tree node command to be processed.
				 Note that the tag of this node is ignored;
				 <@icode{space}/> and <@icode{base}/> parameters
				 are used instead.
			      </desc:param>
			      <desc:param name="lang">
				 The language object to be used for child elements.
				 This permits two or more languages to be freely mixed.
				 For example consider language object <@icode{l1(l2())}/>
				 where <@icode{l1}/> handles <@verb{"a:"}/> tags
				 and <@icode{l2}/> handles <@verb{"b:"}/> tags.
				 When processing a <@verb{"b:"}/> element
				 <@icode{l1}/> will pass the element on to the
				 underlying <@icode{l2}/>
				 where the value of <@icode{lang}/>
				 will be <@icode{l1(l2())}/>. This permits
				 both <@verb{"a:"}/> and <@verb{"b:"}/> elements
				 to appear as children as a <@verb{"b:"}/> element.
			      </desc:param>
			      <desc:result>
				 The underlying language object is called
				 and its result returned.
			      </desc:result>
			   </desc:func>
			</section:name>
		     </section:lettered>
		     <section:lettered name="Constants" sort="fold">
			<section:name name="true">
			   <desc:const name="true" type="boolean" default='"true"'>
			      The boolean true literal.
			   </desc:const>
			</section:name>
			<section:name name="false">
			   <desc:const name="false" type="boolean" default='"false"'>
			      The boolean false literal.
			   </desc:const>
			</section:name>
			<section:name name="null">
			   <desc:const name="null" type="void">
			      A literal for the only value of the <@icode{void}/> type.
			   </desc:const>
			</section:name>
			<section:name name="eol">
			   <desc:const name="eol" type="string" default='"&#X0A;"'>
			      A string containing a single end of line (line-feed) character.
			   </desc:const>
			</section:name>
			<section:name name="nbsp">
			   <desc:const name="nbsp" type="string">
			      A string containing a single non-breaking space character
			      (<verb>&amp;#XA0;</verb>).
			   </desc:const>
			</section:name>
			<section:name name="quot">
			   <desc:const name="quot" type="string" default="'&#X22;'">
			      A string containing a single double quote character.
			   </desc:const>
			</section:name>
			<section:name name="apos">
			   <desc:const name="apos" type="string" default='"&#X27;"'>
			      A string containing a single apostrophe (single quote) character.
			   </desc:const>
			</section:name>
			<section:name name="tab">
			   <desc:const name="tab" type="string" default='"&#X09;"'>
			      A string containing a single horizontal tab character.
			   </desc:const>
			</section:name>
			<section:name name="amp">
			   <desc:const name="amp" type="string">
			      A string containing a single ampersand (<verb>&amp;</verb>) character.
			   </desc:const>
			</section:name>
			<section:name name="lt">
			   <desc:const name="lt" type="string" default='"&#X3C;"'>
			      A string containing a single less than character.
			   </desc:const>
			</section:name>
			<section:name name="gt">
			   <desc:const name="gt" type="string" default='"&#X3E;"'>
			      A string containing a single greater than character.
			   </desc:const>
			</section:name>
			<section:name name="empty">
			   <desc:const name="empty" type="boolean" default='""'>
			      The empty string;
			   </desc:const>
			</section:name>
			<section:name name="options">
			   <desc:const name="options" type="rec">
			      This record contains the value of all interpreter options.
			   </desc:const>
			</section:name>
			<section:name name="passed">
			   <desc:const name="passed" type="rec">
			      This record contains named values passed into this interpreter
			      invocation.
			   </desc:const>
			</section:name>
			<section:name name="myPath">
			   <desc:const name="myPath" type="string">
			      The script path for the script in which this constant reference appears.
			   </desc:const>
			</section:name>
			<section:name name="doBreak">
			   <desc:const name="doBreak" type="boolean">
			      Value is <@icode{true}/> if a <ref:tag name="x:break"/> command
			      was executed previously during the current loop body execution.
			      Normally, this constant is only used in implementing iterators.
			   </desc:const>
			</section:name>
			<section:name name="lang:current">
			   <desc:const name="lang:current">
			      The current language object.
			      See <ref:numbered name="Language Definition"/>.
			   </desc:const>
			</section:name>
		     </section:lettered>
		     <section:lettered name="Prefix Operators">
			<section:preop name="~">
			   <part name="Description">
			      <p>
				 The tilde prefix operator is used to assert that its
				 <@icode{boolean}/> operand is <@icode{true}/>.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {~ a}/>
				 is equivalent to
				 <@code {Assert(a)}/>
			      </p>

			      <p>
				 The form
				 <@code {~#b a}/>
				 is equivalent to
				 <@code{b.sys:Assert(a)}/>
			      </p>
			   </part>
			</section:preop>
			<section:preop name="-">
			   <part name="Description">
			      <p>
				 Prefix minus is used by convention for negation.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {- a}/>
				 is equivalent to
				 <@code {Minus(a)}/>
			      </p>

			      <p>
				 The form
				 <@code { -#b a}/>
				 is equivalent to
				 <@code{b.sys:Minus(a)}/>
			      </p>
			   </part>
			</section:preop>
			<section:preop name="!">
			   <part name="Description">
			      <p>
				 The exclamation point is used by convention for boolean not.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {! a}/>
				 is equivalent to
				 <@code {Not(a)}/>
			      </p>

			      <p>
				 The form
				 <@code { !#b a}/>
				 is equivalent to
				 <@code{b.sys:Not(a)}/>
			      </p>
			   </part>
			</section:preop>
			<section:preop name="%">
			   <part name="Description">
			      <p>
				 The percent prefix operator has special semantics
				 that is used for variable length parameter lists.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {% a}/>
				 is equivalent to
				 <@code {Percent(a)}/>
			      </p>
			   </part>
			</section:preop>
			<section:preop name="**">
			   <part name="Description">
			      <p>
				 The double star operator by convention
				 is used when unparsing an <@icode{xdom:value}/> tree nodes.
				 Such nodes are for internal use only and when unparsed,
				 the double star operator serves as a place holder.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {** a}/>
				 is equivalent to
				 <@code {XDOMValue(a)}/>
			      </p>
			      <p>
				 The form
				 <@code { **#b a}/>
				 is equivalent to
				 <@code{b.sys:XDOMValue(a)}/>
			      </p>
			   </part>
			</section:preop>
		     </section:lettered>
		     <section:lettered name="Infix Operators">
			<section:inop name="=">
			   <part name="Description">
			      <p>
				 The equal infix operator has special semantics.
				 Its left operand should always be an <ref:nt name="id"/>.
				 It is used for named parameters and for named attributes.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a = b}/>
				 is equivalent to
				 <@code {Equal(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name=":=">
			   <part name="Description">
			      <p>
				 The colon equals operator has special semantics and is used for assignment.
			      </p>
			      <p>
				 Equality is related to assignment,
				 so after you execute
				 <@code{a := b}/>
				 by convention the following assertion should hold
				 <@code{~ a == b}/>
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a := b}/>
				 is equivalent to
				 <@code {Assign(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a ==#c b}/>
				 is equivalent to
				 <@code{c.sys:Eq(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="==">
			   <part name="Description">
			      <p>
				 Equality by convention returns <ref:name name="true"/> when two values are equal,
				 and <ref:name name="false"/> otherwise.
				 For some types equality is <ref:gloss name="value equality"/> and for other types
				 equality is <ref:gloss name="reference equality"/>.
			      </p>
			      <p>
				 Equality is related to assignment,
				 so after you execute
				 <@code{a := b}/>
				 by convention the following assertion should hold
				 <@code{~ a == b}/>
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a == b}/>
				 is equivalent to
				 <@code {Eq(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a ==#c b}/>
				 is equivalent to
				 <@code{c.sys:Eq(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="!=">
			   <part name="Description">
			      <p>
				 Inequality by convention returns <ref:name name="false"/> when two values are equal,
				 and <ref:name name="true"/> otherwise.
			      </p>
			      <p>
				 By convention
				 <@code{~ !(a==b) == (a==b)}/>
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a != b}/>
				 is equivalent to
				 <@code {Ne(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a !=#c b}/>
				 is equivalent to
				 <@code{c.sys:Ne(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="<">
			   <part name="Description">
			      <p>
				 Less than by convention returns <ref:name name="true"/> when the
				 first value is less than the second value,
				 and <ref:name name="false"/> otherwise.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a < b}/>
				 is equivalent to
				 <@code {Less(a,b)}/>
				 </p>

				 <p>
				    The form
				    <@code {a <#c b}/>
				    is equivalent to
				    <@code{c.sys:Less(a,b)}/>
				    </p>
				    </part>
			</section:inop>
			<section:inop name=">">
			   <part name="Description">
			      <p>
				 Greater than by convention returns <ref:name name="true"/> when the
				 first value is greater than the second value,
				 and <ref:name name="false"/> otherwise.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a > b}/>
				 is equivalent to
				 <@code {Greater(a,b)}/>
				 </p>
				 <p>
				    The form
				    <@code {a >#c b}/>
				    is equivalent to
				    <@code{c.sys:Greater(a,b)}/>
				    </p>
				    </part>
			</section:inop>
			<section:inop name="<=">
			   <part name="Description">
			      <p>
				 Less than or equal by convention returns <ref:name name="true"/> when the
				 first value is less than or equal to the second value,
				 and <ref:name name="false"/> otherwise.
			      </p>
			   </part>

			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a <= b}/>
				 is equivalent to
				 <@code {LessEq(a,b)}/>
				 </p>

				 <p>
				    The form
				    <@code {a <=#c b}/>
				    is equivalent to
				    <@code{c.sys:LessEq(a,b)}/>
				    </p>
				    </part>
			</section:inop>
			<section:inop name=">=">
			   <part name="Description">
			      <p>
				 Greater than or equal by convention returns <ref:name name="true"/> when the
				 first value is greater than or equal the second value,
				 and <ref:name name="false"/> otherwise.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a >= b}/>
				 is equivalent to
				 <@code {GreaterEq(a,b)}/>
				 </p>

				 <p>
				    The form
				    <@code {a >=#c b}/>
				    is equivalent to
				    <@code{c.sys:GreaterEq(a,b)}/>
				    </p>
				    </part>
			</section:inop>
			<section:inop name="&amp;">
			   <part name="Description">
			      <p>
				 Ampersand is used by convention for boolean and and set intersection.
				 Boolean and is <ref:gloss name="short-circuited"/>.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a & b}/>
				 is equivalent to
				 <@code {And(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a &#c b}/>
				 is equivalent to
				 <@code{c.sys:And(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="|">
			   <part name="Description">
			      <p>
				 Vertical bar is used by convention for boolean or and and set union.
				 Boolean or is <ref:gloss name="short circuited"/>.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a | b}/>
				 is equivalent to
				 <@code {Or(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a |#c b}/>
				 is equivalent to
				 <@code{c.sys:Or(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="^">
			   <part name="Description">
			      <p>
				 Caret is used by convention for boolean exclusive or.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a ^ b}/>
				 is equivalent to
				 <@code {Xor(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a ^#c b}/>
				 is equivalent to
				 <@code{c.sys:Xor(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="++">
			   <part name="Description">
			      <p>
				 Double plus is used by convention for string concatenation.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a ++ b}/>
				 is equivalent to
				 <@code {Cat(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a ++#c b}/>
				 is equivalent to
				 <@code{c.sys:Cat(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="+">
			   <part name="Description">
			      <p>
				 Plus is used by convention for addition.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a + b}/>
				 is equivalent to
				 <@code {Add(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a +#c b}/>
				 is equivalent to
				 <@code{c.sys:Add(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="-">
			   <part name="Description">
			      <p>
				 Minus is used by convention for subtraction.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a - b}/>
				 is equivalent to
				 <@code {Sub(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a -#c b}/>
				 is equivalent to
				 <@code{c.sys:Sub(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="*">
			   <part name="Description">
			      <p>
				 Star is used by convention for multiplication.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a * b}/>
				 is equivalent to
				 <@code {Mult(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a *#c b}/>
				 is equivalent to
				 <@code{c.sys:Mult(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="/">
			   <part name="Description">
			      <p>
				 Slash is used by convention for division.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a / b}/>
				 is equivalent to
				 <@code {Div(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a /#c b}/>
				 is equivalent to
				 <@code{c.sys:Div(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="/+">
			   <part name="Description">
			      <p>
				 Slash plus is used by convention for integer remainder.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a /+ b}/>
				 is equivalent to
				 <@code {Rem(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a /+#c b}/>
				 is equivalent to
				 <@code{c.sys:Rem(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="~">
			   <part name="Description">
			      <p>
				 The tilde infix operator by convention is used to assert
				 that its left operand has the type or view
				 given by its right operand.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a ~ b}/>
				 is equivalent to
				 <@code {Tilde(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a ~#c b}/>
				 is equivalent to
				 <@code{c.sys:Tilde(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="?">
			   <part name="Description">
			      <p>
				 The question infix operator by convention is used to test
				 if its left operand has the type or view
				 given by its right operand.
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a ? b}/>
				 is equivalent to
				 <@code {Question(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a ~#c b}/>
				 is equivalent to
				 <@code{c.sys:Question(a,b)}/>
			      </p>
			   </part>
			</section:inop>
			<section:inop name="..">
			   <part name="Description">
			      <p>
				 The double dot range operation by convention is used to specify a range
				 of values that are to be iterated over.
			      </p>
			      <p>
			      </p>
			   </part>
			   <part name="Semantics">
			      <p>
				 The form
				 <@code {a .. b}/>
				 is equivalent to
				 <@code {Range(a,b)}/>
			      </p>

			      <p>
				 The form
				 <@code {a ..#c b}/>
				 is equivalent to
				 <@code{c.sys:Range(a,b)}/>
			      </p>
			   </part>
			</section:inop>
		     </section:lettered>
		     <section:lettered name="Interpreter Options" sort="fold">
			<section:option name="optimize">
			   <desc:var name="optimize" type="boolean" default="true">
			      Enables optimizations including streaming.
			   </desc:var>
			</section:option>
			<section:option name="check">
			   <desc:var name="check" type="boolean" default="true">
			      Check assertions.
			   </desc:var>
			</section:option>
			<section:option name="streamTop">
			   <desc:var name="streamTop" type="boolean" default="false">
			      Enable top-level streaming.
			   </desc:var>
			</section:option>
			<section:option name="flushDebugAfter">
			   <desc:var name="flushDebugAfter" type="boolean" default="true">
			      Flush stream at debug points.
			   </desc:var>
			</section:option>
			<section:option name="debug">
			   <desc:var name="debug" type="boolean" default="false">
			      Break at start of main script or function execution.
			   </desc:var>
			</section:option>
			<section:option name="debugAll">
			   <desc:var name="debugAll" type="boolean" default="false">
			      Break at the start of execution of every script.
			   </desc:var>
			</section:option>
			<section:option name="debugError">
			   <desc:var name="debugError" type="boolean" default="true">
			      Break after every error.
			   </desc:var>
			</section:option>
			<section:option name="debugWarn">
			   <desc:var name="debugWarn" type="boolean" default="false">
			      Break after every warning or error.
			   </desc:var>
			</section:option>
			<section:option name="scriptOnly">
			   <desc:var name="scriptOnly" type="boolean" default="false">
			      Run only script (not named function).
			   </desc:var>
			</section:option>
			<section:option name="funcOnly">
			   <desc:var name="funcOnly" type="boolean" default="false">
			      Run only named function (not script).
			   </desc:var>
			</section:option>
			<section:option name="asciiXML">
			   <desc:var name="asciiXML" type="boolean" default="false">
			      Output escaped to ASCII using XML escapes.
			      Non-breaking space (<@icode{nbsp}/>) is escaped to <@verb{"&amp;nbsp;"}/>.
			      Characters less then <@icode{32}/> (except cariage return and line feed)
			      and characters greater than or equal to <@icode{127}/> (other than non-breaking space)
			      are escaped using XML hex <ref:nt name="escape"/>s.
			      This same escape code is also available in the <@icode{asciiXML}/> function.
			   </desc:var>
			</section:option>
			<section:option name="charSet">
			   <desc:var name="charSet" type="string" default='"ISO-8859-1"'>
			      The <ref:numbered name="Character Set"/> to use for <ref:nt name="script"/>
			      output.
			   </desc:var>
			</section:option>
			<section:option name="errorMax">
			   <desc:var name="errorMax" type="int" default="20">
			      Maximum number of errors to log.
			   </desc:var>
			</section:option>
			<section:option name="scriptDir">
			   <desc:var name="scriptDir" type="string" default='"c:\xact\scripts"'>
			      Location of scripts.
			   </desc:var>
			</section:option>
			<section:option name="logDir">
			   <desc:var name="scriptDir" type="string" default='"c:\xact\logs"'>
			      Location of log files.
			   </desc:var>
			</section:option>
			<section:option name="scriptPrefix">
			   <desc:var name="scriptPrefix" type="string" default='""'>
			      May only run scripts whose script paths start with this prefix.
			   </desc:var>
			</section:option>
			<section:option name="mime">
			   <desc:var name="mime" type="string" default='""'>
			      If not empty, the mime type to be output.
			      For HTML output this is often set to <@icode{"txt/html"}/>.
			   </desc:var>
			</section:option>
			<section:option name="defaultScript">
			   <desc:var name="defaultScript" type="string" default='"default"'>
			      If no script is specified, the default script to run.
			   </desc:var>
			</section:option>
			<section:option name="errorScript">
			   <desc:var name="errorScript" type="string" default='"error"'>
			      Error handling script.
			   </desc:var>
			</section:option>
			<section:option name="inter">
			   <desc:var name="inter" type="string" default='"xact.bat"'>
			      The name of the &xact; interpreter.
			      This used in generating URLs to other &xact; scripts.
			   </desc:var>
			</section:option>
			<section:option name="fileSep">
			   <desc:const name="fileSep" type="string">
			      The platform specific file separator.
			      This is typically either <@icode{"/"}/> (for Unix)
			      or <@icode{"\"}/> (for Windows).
			   </desc:const>
			</section:option>
			<section:option name="os">
			   <desc:const name="os" type="string">
			      The platform specific operating system name.
			   </desc:const>
			</section:option>
			<section:option name="id">
			   <desc:const name="id" type="string">
			      Process id.
			   </desc:const>
			</section:option>
			<section:option name="version">
			   <desc:const name="version" type="string">
			      The &xact; interpreter version.
			   </desc:const>
			</section:option>
			<section:option name="currentDir">
			   <desc:const name="currentDir" type="string">
			      The directory from which the &xact; interpreter was invoked.
			   </desc:const>
			</section:option>
			<section:option name="startTime">
			   <desc:const name="startTime" type="date">
			      The date and time at which the &xact; interpreter was started.
			   </desc:const>
			</section:option>
		     </section:lettered>
		     <section:lettered name="Glossary" sort="fold">
			<section:gloss name="CGI">
			   <p>
			      The Common Gateway Interface permits <ref:gloss name="HTTP"/> web wervers
			      to execute scripts.
			      For more information see
			   </p>
			   <p>
			      <a ref="http://www.w3.org/CGI/"/>
			   </p>
			</section:gloss>
			<section:gloss name="servlet">
			   <p>
			      A Java Servlet provides a way for web servers to
			      run Java code.
			      For more information see
			   </p>
			   <p>
			      <a ref="http://java.sun.com/products/servlet/"/>
			   </p>
			</section:gloss>
			<section:gloss name="HTTP">
			   <p>
			      The HyperText Transfer Protocol is used to communicate
			      between web browsers and web servers. For more information
			      see
			   </p>
			   <p>
			      <a ref="http://www.w3.org/Protocols/"/>
			   </p>
			</section:gloss>
			<section:gloss name="JSP">
			   <p>
			      Java Server Pages provide a way to call
			      Java code from within an <ref:gloss name="HTML"/>
			      page. For more information see
			   </p>
			   <p>
			      <a ref="http://java.sun.com/products/jsp/"/>
			   </p>
			</section:gloss>
			<section:gloss name="precedence">
			   <p>
			   The rules for determining the order in which
			   infix and prefix operations in <ref:nt name="exp"/>s are performed.
			   </p>
			   <p>
			      For example in <@icode{a+b*c}/> the
			      multiplication (<ref:inop name="*"/>) is performed
			      before the add (<ref:inop name="+"/>)
			      because the precedence of <ref:inop name="*"/> (11) is higher than
			      the precedence of <ref:inop name="+"/> (10).
			   </p>
			   <p>
			      The <ref:table name="Precedence"/> table gives
			      the precedence of all operators.
			   </p>
			</section:gloss>
			<section:gloss name="value equality">
			   <p>
			      Reference equality is when the <ref:inop name="=="/> operation
			      returns <@icode{true}/> only when the operands have the same value.
			   </p>
			   <p>
			      See also <ref:gloss name="reference equality"/>.
			   </p>
			</section:gloss>
			<section:gloss name="reference equality">
			   <p>
			      Reference equality is when the <ref:inop name="=="/> operation
			      returns <@icode{true}/> only when the operands reference the same data.
			   </p>
			   <p>
			      See also <ref:gloss name="value equality"/>.
			   </p>
			</section:gloss>
			<section:gloss name="short circuited">
			   The boolean <ref:name name="And"/> (<ref:inop name="&amp;"/>)
			   and <ref:name name="Or"/> (<ref:inop name="|"/>) operations have the property
			   that if their result can be determined from initial
			   parameters, then later parameters are not evaluated.
			   For example when executing <@icode{a&b}/>, if
			   the value of <@icode{a}/> is <@icode{true}/> then the expression <@icode{b}/> is not
			   evaluated.
			</section:gloss>
			<section:gloss name="sugar">
			   See <ref:gloss name="syntactic sugar"/>.
			</section:gloss>
			<section:gloss name="syntactic sugar">
			   <p>
			      When people write and read &xact; scripts there
			      is a wide variety of syntactic forms that provide
			      "natural" ways of expressing computations.
			      When the &xact; interpreter and other programs process
			      &xact; programs having all these different forms
			      could make processing more complex.
			      To solve this problem, many of the syntactic forms
			      are considered to be syntactic sugar and are
			      replaced during parsing with other forms resulting
			      in an <ref:name name="xdom"/> parse tree with a much
			      smaller number of forms. 
			   </p>
			   <p>
			      For example the special form <@icode{a.b}/> is
			      replaced by a function call of the form <@icode{Dot["b"](a)}/> during
			      parsing.
			   </p>
			   <p>
			      See also <ref:gloss name="desugar"/>.
			   </p>
			</section:gloss>
			<section:gloss name="desugar">
			   <p>
			      The process during parsing of replacing <ref:gloss name="syntactic sugar"/> with
			      with another form.
			   </p>
			   <p>
			      For example, the expression <@icode{a+b}/> is desugared 
			      to <@icode{Add(a,b)}/>.
			   </p>
			</section:gloss>
			<section:gloss name="view">
			   <p>
			      A view is similar to a type in that it defines a permitted set
			      of values and an associated set of operations.
			      While every &xact; value has a single type, it can have multiple views.
			      For example, &xact; strings all have type <@icode{string}/>.
			      But views <@icode{fold}/> and <@icode{boolean}/> can be applied to
			      string values.
			   </p>
			   <p>
			      When a view is being used it must be explicitly specified.
			      For example <@icode{"abc"=="ABC"}/> compares the two strings
			      with the type <@icode{string}/> equality operation
			      that here returns <@icode{false}/>.
			      But <@icode{"abc"==#fold"ABC"}/> compare the two strings
			      with the view <@icode{fold}/> equality operation
			      which here returns <@icode{true}/>.
			   </p>
			</section:gloss>
			<section:gloss name="script path">
			   <p>
			      A script path is used to name scripts.
			      See <ref:numbered name="Script Paths"/>.
			   </p>
			</section:gloss>
			<section:gloss name="LHS/RHS">
			   <p>
			      &xact; allows functions to appear on both the left-hand-side (LHS) and
			      right-hand-side (RHS) of assignments.
			      This is handy when defining abstractions such as dot qualifications
			      and subscripting that are handle to use in both places.
			      IT is also handy for referencing type data components.
			      Unlike Java that requires separate getter and setter functions,
			      in &xact; they can be combined into a single LHS/RHS function.
			      Consider a couple of examples.
			   </p>
			   <@code{
			      @x:var r := rec(a=3);
			      @x:var a := array(1,2,3);
			      r.a := r.a + 1;
			      a(3) := 2* a(3)
			   }/>
			   <p>
			      LHS/RHS functions are declared with two <ref:tag name="x:func"/> declarations
			      for the same name, one with the <@verb{"lhs"}/> option and the other
			      with the <@verb{"rhs"}/> option.
			      </p>
			   <p>
			      For more information see <ref:numbered name="LHS and RHS"/>.
			   </p>
			</section:gloss>
			<section:gloss name="iterator">
			   An iterator is an abstraction that generates a set
			   of values and then executes a body of code for each of those values.
			   Iterators are declared as functions
			   using the <ref:tag name="x:func"/> command and invoked via the <ref:tag name="x:for"/> command.
			   See also the description of <ref:numbered name="Iterators"/>. 
			</section:gloss>
			<section:gloss name="tag">
			   <p>
			      A tag is the initial identifier in an &xact; command or
			      XML element.
			      Consider the example.
			   </p>
			   <@code{
			   @x:if show {
			      <b>Test Show</b>
			   }
			   }/>
			   <p>
			      Here the tags are <@verb{"x:if"}/> and <@verb{"b"}/>.
			   </p>
			   <p>
			      See also <ref:gloss name="namespace"/>.
			   </p>
			</section:gloss>
			<section:gloss name="namespace">
			   <b>
			      The part of a <ref:gloss name="tag"/> that precedes
			      the initial colon. The namespace is used in XML to
			      distinguish different kinds of data and in &xact; commands
			      to distinguish commands in different sublanguages.
			      For example in the tag <@verb{"x:if"}/> the namespace is <@verb{"x"}/>.
			   </b>
			</section:gloss>
			<section:gloss name="XML">
			   <p>
			      The Extensible Markup Language, XML, is a standard format for
			      representing tree structured textual information.
			      The &xact; language includes most XML syntax.
			      &xact; contains extensive support for parsing, processing,
			      and unparsing XML.
			      For more information about XML see
			   </p>
			   <p>
			      <a ref="http://www.w3.org/XML/"/>
			   </p>
			</section:gloss>
			<section:gloss name="HTML">
			   See <ref:gloss name="XHTML"/>.
			</section:gloss>
			<section:gloss name="XHTML">
			   <p>
			   XHTML is the latest form of the HTML (Hypertext Markup Language)
			   that fully <ref:gloss name="XML"/> based.
			   XHTML is the primary language for publishing hypertext to the
			   World Wide Web.
			   &xact; contains extensive features for generating web pages
			   and for working with XHTML.
			   For more information about XHTML see
			   </p>
			   <p>
			      <a ref="http://www.w3.org/MarkUp/"/>
			   </p>
			</section:gloss>
			<section:gloss name="Java">
			   <p>
			   The &xact; interpreter is written in Java.
			   &xact; scripts can call Java code and Java programs
			   can invoke the &xact; interpreter.
			   For more information about Java see
			   </p>
			   <p>
			      <a ref="http://java.sun.com"/>
			   </p>
			</section:gloss>
			<section:gloss name="streaming">
			   <p>
			      Streaming a a special optimization in which a <@icode{string}/> value is processed incrementally.
			      Consider for example the following code that copies a file.
			   </p>
			   <@code{
			   outfile.write#file(infile.read#file())
			   }/>
			   <p>
			      Logically the entire input file is read into a single string result
			      and then that string is written to the output file.
			      With streaming the data is moved in chunks so that only
			      small chunks of the string are in memory at any given time.
			   </p>
			   <p>
			      For more information see <ref:numbered name="Streaming"/>.
			   </p>
			</section:gloss>
			<section:gloss name="xdom">
			   The &xact; Document Object Model is a data structure
			   that is used to represent the trees that result
			   from parsing &xact; scripts. Xdom trees can also be used
			   for <ref:gloss name="XML"/>.
			   Xdom data structures are not restricted to just trees
			   but can be used to represent arbitrary directed graphs.
			   For more information about Xdoms see the <ref:name name="xdom"/> view.
			</section:gloss>
			<section:gloss name="join">
			   <p>
			      Join rules determine the result of a sequence of expressions.
			      Consider for example.
			   </p>
			   <@icode{
			      @x:block{
			         a;
			         b;
			      }
			   }/>
			   <p>
			      The result of the block will be the result of joining the value of <@icode{a}/> to
			      the value of <@icode{b}/>.
			      If one value if <@icode{null}/> then the joined result is the other
			      value.
			      If both values are <@icode{string}/>s, then the result
			      is <@icode{a++b}/>.
			   </p>
			   <p>
			      For more information see <ref:numbered name="Join Rules"/>.
			   </p>
			</section:gloss>
			<section:gloss name="cover">
			   <p>
			      Cover rules permit mixed type arithmetic.
			      Consider for example <@icode{a+b}/>.
			      If <@icode{a}/> and @icode{b}/> have the same
			      type then the <@icode{sys:Add}/> operation
			      for that type is used. If however <@icode{a}/> and <@icode{b}/> have
			      different types, then cover rules determine which of those two types
			      to use. 
			   </p>
			   <p>
			      Consider for example, <@icode{2+3.5}/>. Since the
			      type <@icode{float}/> covers <@icode{int}/>, the <@icode{float.sys:Add}/> operation
			      is used.
			      Cover rules are given by <@icode{sys:Cover}/> type operations.
			      For the example here, <@icode{float.sys:Cover(2)}/> returns <@icode{true}/>.
			   </p>
			</section:gloss>
		     </section:lettered>
		     <include name="examples"/>
		     </section:top>
		     <section:top name="Libraries">
			<section:library name="library:enum">
			   <section:name type="view" name="enum">
			   View that
			   supports enumerated values.
			   <desc:view name="enum" ext="true">
			      <desc:varparam name="values" kind="ext">
				 A list of values.
			      </desc:varparam>
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="string">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{true}/> if <@icode{v}/> is
				    in the list of <@icode{values}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Eq">
				 <desc:param name="a" type="enum[%values]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="enum[%values]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    Result is <@icode{a==b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Ne">
				 <desc:param name="a" type="enum[%values]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="enum[%values]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    Result is <@icode{a!=b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Less">
				 <desc:param name="a" type="enum[%values]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="enum[%values]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:LessEq">
				 <desc:param name="a" type="enum[%values]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="enum[%values]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    Result is <@icode{a <#enum[%values] b | a ==#enum[%values] b}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:Greater">
				 <desc:param name="a" type="enum[%values]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="enum[%values]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    Result is <@icode{true}/> if <@icode{a}/> follows <@icode{b}/> in
				    the list of <@icode{values}/>.
				 </desc:result>
			      </desc:func>
			      <desc:func name="sys:GreaterEq">
				 <desc:param name="a" type="enum[%values]">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="enum[%values]">
				    second parameter
				 </desc:param>
				 <desc:result type="boolean">
				    Result is <@icode{a >#enum[%values] b | a ==#enum[%values] b}/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			   <part name="Examples">
			      <@code{
			      @x:const color := enum["red","green","blue"];
			      @x:var c~color := "red";
			      ~ c <#color "green";
			      ~ c > "green";
			      }/>
			   </part>
			   </section:name>
			   <section:unnumbered name="SRC library:enum">
			      <lcode name="enum"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:escape">
			   <section:name type="func" name="asciiXML">
			      <p>
				 This function takes a string and
				 escapes it using XML escapes so it contains only ASCII characters.
			      </p>
			      <desc:func name="asciiXML">
				 <desc:param name="s" type="string">
				    a string value.
				 </desc:param>
				 <desc:result type="string">
				    The escaped string.
				    Non-breaking space (<@icode{nbsp}/>) is escaped to <@verb{"&amp;nbsp;"}/>.
				    Characters less then <@icode{32}/> (except cariage return and line feed)
				    and characters greater than or equal to <@icode{127}/> (other than non-breaking space)
				    are escaped using XML hex <ref:nt name="escape"/>s.
				    The <ref:option name="asciiXML"/> option applies this same
				    set of escapes to program output.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="func" name="escapeDoubleString">
			      <p>
				 This function escapes characters so that arbitrary
				 text can be placed within a double quoted <ref:nt name="string"/>.
			      </p>
			      <desc:func name="escapeDoubleString">
				 <desc:param name="s" type="string">
				    a string value.
				 </desc:param>
				 <desc:result type="string">
				    The escaped string.
				    Specifically the characters <@verb{"&amp;"}/> and <@verb{'"'}/> are
				    escaped.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="func" name="escapeSingleString">
			      <p>
				 This function escapes characters so that arbitrary
				 text can be placed within a single quoted <ref:nt name="string"/>.
			      </p>
			      <desc:func name="escapeSingleString">
				 <desc:param name="s" type="string">
				    a string value.
				 </desc:param>
				 <desc:result type="string">
				    The escaped string.
				    Specifically the characters <@verb{"&amp;"}/> and <@verb{"'"}/> are
				    escaped.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="func" name="escapeXMLText">
			      <p>
				 This function escapes characters so that arbitrary
				 text can be placed within as <ref:nt name="xml"/> text.
			      </p>
			      <desc:func name="escapeXMLText">
				 <desc:param name="s" type="string">
				    a string value.
				 </desc:param>
				 <desc:result type="string">
				    The escaped string.
				    Specifically the characters <@verb{"&amp;"}/>,
				    <@verb{"<"}/>, and <@verb{">"}/> are
				    escaped.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="func" name="quoteXML">
			      <p>
				 This function permits an arbitrary  <@icode{string}/> value
				 to be correctly displayed on an <ref:gloss name="XHTML"/> page.
			      </p>
			      <desc:func name="quoteXML">
				 <desc:param name="s" type="string">
				    a string value.
				 </desc:param>
				 <desc:result type="string">
				    the value of <@icode{s}/> escaped to display as HTML.
				    This includes escaping special HTML characters <@verb{"<"}/>, <@verb{">"}/>,
				    and <@verb{"&amp;"}/>.
				    It also changes spaces to nonbreaking spaces and inserts <@verb{"<br/>"}/> tags
				    at the end of lines.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:escape">
			      <lcode name="escape"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:graph">
			   <section:name type="func" name="graphExpand">
			      <p>
			      This func is used to relink a <ref:numbered name="Graphs"/> output by
			      <@icode{Unparse}/> using the <@icode{graph=true}/> option.
			      See the <ref:example name="graph"/> example to see how this works.
			      </p>
			      <desc:func name="graphExpand">
				 <desc:param name="t" type="xdom">
				    The result of parsing the output of <@icode{Unparse}/>
				    with <@icode{graph=true}/>.
				 </desc:param>
				 <desc:result type="xdom">
				    Result is the linked graph: a modified version of <@icode{t}/> with graph defs and uses
				    replaced by links. Note the graph is modified in place, not copied.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:graph">
			      <lcode name="graph"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:html">
			   <section:unnumbered name="INTRO library:html">
			     <p>
			      This library provides support for generating <ref:gloss name="HTML"/>.
			     </p>
			   </section:unnumbered>
			   <section:name type="func" name="A">
			      <p>
				 This function is used to generate an <@icode{xdom:element}/> node
				 that is an <ref:gloss name="HTML"/> <@icode{a}/> tag that
				 represents a call to another &xact; script.
				 This call often appears as attribute of a <ref:tag name="x:tag"/> command.
			      </p>
			      <desc:func name="A" ext="true">
				 <desc:param name="path" type="string" kind="ext">
				    the script path of the script to be called.
				 </desc:param>
				 <desc:nparam name="pass" kind="ext" type="rec" default="rec()" optional="true">
				    additional values to be passed in the call.
				 </desc:nparam>
				 <desc:nparam name="inter" type="string" default="options.inter#rec" optional="true" kind="ext">
				    the name of the &xact; interpreter.
				 </desc:nparam>
				 <desc:nparam name="prefix" type="string" default='""' optional="true" kind="ext">
				    a string to insert at the beginning of the generated URL.
				 </desc:nparam>
				 <desc:varparam name="args">
				    a list of <@icode{string}/> parameters to be passed.
				 </desc:varparam>
			      </desc:func>
			      <part name="Examples">
				 <p>
				    The following command
				 </p>
				 <@icode{
				 @x:tag A[ABS.a:b,inter="xx",pass=rec(a="3",b="false")]("a","b","d e+f") { "test ab" }
				 }/>
				 <p>
				    produces the following output
				 </p>
				 <@icode{
				 <a href="xx?a:b(a,b,d+e!(=43)f)&amp;a=3&amp;b=false">test ab</a>
				 }/>
			      </part>
			   </section:name>
			   <section:name type="func" name="ABS">
			      <p>
				 This view is a convenient way of specifying
				 absolute script paths.
				 For example <@icode{ABS.x:y}/> returns
				 <@icode{"x:y"}/>.
				 See also <ref:name name="REL"/>.
			      </p>
			      <desc:view name="ABS">
				 <desc:func name="sys:Dot" ext="true" param="false">
				    <desc:param name="name" type="string" kind="ext">
				       the absolute script path
				    </desc:param>
				    <desc:result type="string">
				       The result is <@icode{name}/>.
				    </desc:result>
				 </desc:func>
			      </desc:view>
			   </section:name>
			   <section:name type="func" name="FORM">
			      <p>
				 This function is used to generate an <@icode{xdom:element}/> node
				 that is an <ref:gloss name="HTML"/> <@icode{form}/> tag that
				 represents a call to another &xact; script.
				 This call often appears as attribute of a <ref:tag name="x:tag"/> command.
			      </p>
			      <desc:func name="FORM" ext="true">
				 <desc:param name="path" type="string" kind="ext">
				    the script path of the script to be called.
				 </desc:param>
				 <desc:nparam name="pass" kind="ext" type="rec" default="rec()" optional="true">
				    additional values to be passed in the call.
				 </desc:nparam>
				 <desc:nparam name="inter" type="string" default="options.inter#rec" optional="true" kind="ext">
				    the name of the &xact; interpreter.
				 </desc:nparam>
				 <desc:nparam name="prefix" type="string" default='""' optional="true" kind="ext">
				    a string to insert at the beginning of the generated URL.
				 </desc:nparam>
				 <desc:varparam name="args">
				    a list of <@icode{string}/> parameters to be passed.
				 </desc:varparam>
			      </desc:func>
			      <part name="Examples">
				 <p>
				    The following command
				 </p>
				 <@icode{
				 @x:tag FORM[ABS.a:b,inter="xx",pass=rec(a="3",b="false")]("a","b","d e+f") { "test ab" }
				 }/>
				 <p>
				    produces the following output
				 </p>
				 <@icode{
				 <form href="xx?a:b(a,b,d+e!(=43)f)&amp;a=3&amp;b=false">test ab</form>
				 }/>
			      </part>
			   </section:name>
			   <section:name type="func" name="REL">
			      <p>
				 This view is a convenient way of specifying
				 relative script paths.
				 Suppose that the current scripts as given by <@icode{options.script#rec}/>
				 is <@icode{a:b:c}/>.
				 Now <@icode{REL.x:y}/> returns <@icode{"a:b:x:y"}/>.
				 See also <ref:name name="REL"/>.
			      </p>
			      <p>
				 It is also possible to specify the path from which to be relative.
				 For example <@icode{REL["m:n"].x:y}/> returns <@icode{"m:n:x:y"}/>
			      </p>
			      <desc:view name="REL">
				 <desc:func name="sys:Dot" ext="true" param="false">
				    <desc:param name="name" type="string" kind="ext">
				       the relative script path
				    </desc:param>
				    <desc:result type="string">
				       The result is the corresponding absolute script path.
				    </desc:result>
				 </desc:func>
			      </desc:view>
			      <desc:view name="REL" ext="true">
				 <desc:param name="path" type="string" kind="ext">
				    the path to be relative to.
				 </desc:param>
				 <desc:func name="sys:Dot" ext="true" param="false">
				    <desc:param name="name" type="string" kind="ext">
				       the relative script path.
				    </desc:param>
				    <desc:result type="string">
				       The result is the corresponding absolute script path.
				    </desc:result>
				 </desc:func>
			      </desc:view>
			   </section:name>
			   <section:unnumbered name="SRC library:html">
			      <lcode name="html"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:iterator">
			   <section:unnumbered name="INTRO library:iterator">
			      <p>
				 This library contains a set of useful iterators.
				 For more about iterators see <ref:numbered name="Iterators"/>.
				 For an example that shows some uses of the
				 iterators in this library see the <ref:example name="iterators"/> example.
			      </p>
			      <p>
				 Many of these iterators are iterator composition,
				 that is iterators that take other iterators as parameters.
			      </p>
			   </section:unnumbered>
			   <section:name type="iterator" name="Accumulate">
			      <p>
				 This iterator takes an iterator and combines its sequence of values.
			      </p>
			      <desc:func name="Accumulate" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
                                     <desc:param name="start" kind="ext">
                                     an initial value.
                                 </desc:param>
                                 <desc:param name="join" type="func" kind="ext">
                                    a function that takes two parameters.
                                 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
                                    If <@icode{iter}/> produces values 1, 2, 3 then
                                     the result will be <@icode{join(join(join(start,act(1)),act(2)),act(3))}/>
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="func" name="Combine">
				 <p>
				    This function combines a sequence
				    of strings from an iterator using a specified
				    separator string.
				 </p>
				 <p>
				    For example the result of combining iterator <@icode{Vals["a","b","c"]}/> using
				    separator string <@icode{","}/> is <@icode{"a,b,c"}/>.
				 </p>
			      <desc:func name="Combine" ext="true" param="false">
				 <desc:param name="iter" kind="ext">
				    an iterator over a sequence of <@icode{string}/>s.
				 </desc:param>
				 <desc:param name="sep" type="string" kind="ext">
				    a separator.
				 </desc:param>
				 <desc:result type="string">
				    The result of combining all iterator <@icode{iter}/> string values
				    using the specified separator <@icode{sep}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="ExceptFirst">
			      <p>
				 This iterator takes an iterator
				 and then iterates over all its values except the first.
			      </p>
			      <desc:func name="ExceptFirst" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates over
				    over all values of <@icode{iter}/> except the first.
				    If <@icode{iter}/> has one value or no values, then
				    <@icode{act}/> is not executed.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="ExceptLast">
			      <p>
				 This iterator takes an iterator
				 and then iterates over all its values except the last.
			      </p>
			      <desc:func name="ExceptLast" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates over
				    over all values of <@icode{iter}/> except the last.
				    If <@icode{iter}/> has one value or no values, then
				    <@icode{act}/> is not executed.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Filter">
			      <p>
				 This iterator takes an iterator
				 and a filtering function and iterates over
				 all values that satisfy the filter.
			      </p>
			      <desc:func name="Filter" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
				 <desc:param name="filter" type="func" kind="ext">
				    filter function. Takes a single parameter and
				    returns a <@icode{boolean}/> result.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates over
				    over all
				    values <@icode{v}/> of <@icode{iter}/> where <@icode{filter(v)}/> returns <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="FilterVal">
			      <p>
				 This iterator takes an iterator,
				 a filtering function, and a filter value and iterates over
				 all values that satisfy the filter.
			      </p>
			      <desc:func name="FilterVal" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
				 <desc:param name="filter" type="func" kind="ext">
				    filter function. Takes two parameters and
				    returns a <@icode{boolean}/> result.
				 </desc:param>
				 <desc:param name="fval" kind="ext">
				    a value.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates over
				    over all
				    values <@icode{v}/> of <@icode{iter}/> where <@icode{filter(v,fval)}/> returns <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Filter2">
			      <p>
				 This iterator takes an iterator with two indexes and
				 a filtering function and iterates over
				 all values that satisfy the filter.
			      </p>
			      <desc:func name="Filter2" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function with two indexes.
				 </desc:param>
				 <desc:param name="filter" type="func" kind="ext">
				    filter function. Takes two parameters and
				    returns a <@icode{boolean}/> result.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates 
				    over all
				    values <@icode{[v1,v2]}/> of <@icode{iter}/> where <@icode{filter(v1,v2)}/> returns <@icode{true}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="First">
			      <p>
				 This iterator takes an iterator
				 and then iterates using only its first value.
			      </p>
			      <desc:func name="First" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates 
				    over the first value of <@icode{iter}/>.
				    If <@icode{iter}/> has no values, then
				    <@icode{act}/> is not executed.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Last">
			      <p>
				 This iterator takes an iterator
				 and then iterates using only its last value.
			      </p>
			      <desc:func name="Last" ext="true">
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates 
				    over the last value of <@icode{iter}/>.
				    If <@icode{iter}/> has no values, then
				    <@icode{act}/> is not executed.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Nest">
			      <p>
				 This iterator takes two other iterators
				 and runs the second nested inside the first.
			      </p>
			      <desc:func name="Nest" ext="true">
				 <desc:param name="iter1" type="func" kind="ext">
				    first iterator function.
				 </desc:param>
				 <desc:param name="iter2" type="func" kind="ext">
				    second iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a two parameters, the first for <@icode{iter1}/> and
				    the second for <@icode{iter2}/>.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates
				    over <@icode{iter1}/> and for each <@icode{iter1}/> value
				    iterates over all <@icode{iter2}/> values.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="NestF">
			      <p>
                                 This iterator is similar to the <ref:name name="Nest"/> iterator
                                    except the second name paramter is a function that takes
                                    the value of the first iterator as a parameter and
                                    returns the second iterator.
			      </p>
			      <desc:func name="NestF" ext="true">
				 <desc:param name="iter1" type="func" kind="ext">
				    first iterator function.
				 </desc:param>
				 <desc:param name="iter2f" type="func" kind="ext">
                                    a function that takes a single parameter and returns an iterator.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a two parameters, the first for <@icode{iter1}/> and
				    the second for the result of calling <@icode{iter2f}/>.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates
				    over <@icode{iter1}/> and for each <@icode{iter1}/> value
				    iterates over all <@icode{iter2f}/> values.
				 </desc:result>
			      </desc:func>
			   <part name="Examples">
                              <@code{
                              @x:func rng[high](low) { low..high }
                              @x:for [i,j] := NestF[1..3, rng[3]] {
                                 i; ":"; j; eol;
                              }
                              }/>
                              </part>
			   </section:name>
			   <section:name type="iterator" name="Parallel">
			      <p>
				 This iterator takes two other iterators
				 and runs them in parallel.
			      </p>
			      <desc:func name="Parallel" ext="true">
				 <desc:param name="iter1" type="func" kind="ext">
				    first iterator function.
				 </desc:param>
				 <desc:param name="iter2" type="func" kind="ext">
				    second iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a two parameters, the first for <@icode{iter1}/> and
				    the second for <@icode{iter2}/>.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates
				    over <@icode{iter1}/> and <@icode{iter2}/> in parallel.
				    It terminates when either of these iterators terminates.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Separate">
				 <p>
				    This iterator function breaks a string
				    into parts based on a separator string.
				 </p>
				 <p>
				    For example the string <@icode{"a,b,c"}/> is
				    separated
				    by <@icode{","}/> into <@icode{"a"}/>, <@icode{"b"}/>, and <@icode{"c"}/>.
				 </p>
			      <desc:func name="Separate" ext="true">
				 <desc:param name="s" type="string" kind="ext">
				    a string
				 </desc:param>
				 <desc:param name="sep" type="string" kind="ext">
				    a separator.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a single parameter of type <@icode{string}/>.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates over
				    all the parts of <@icode{s}/> as separated by <@icode{sep}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Seq">
			      <p>
				 This iterator takes two other iterators
				 and runs them in sequential order.
			      </p>
			      <desc:func name="Seq" ext="true">
				 <desc:param name="iter1" type="func" kind="ext">
				    first iterator function.
				 </desc:param>
				 <desc:param name="iter2" type="func" kind="ext">
				    second iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates 
				    over <@icode{iter1}/> and then over <@icode{iter2}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Slice">
			      <p>
				 This iterator takes an iterator
				 and a filtering function and iterates over
				 all values that satisfy the filter.
			      </p>
			      <desc:func name="Slice" ext="true">
				 <desc:param name="val" kind="ext">
				    a value for which a subscripting operation
				    is defined.
				 </desc:param>
				 <desc:param name="iter" type="func" kind="ext">
				    iterator function.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a one parameter.
				 </desc:param>
				 <desc:result>
				    For all values <@icode{v}/> of <@icode{iter}/>, iterates
				    over <@icode{val(i)}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="iterator" name="Vals">
			      <desc:func name="Vals" ext="true">
				 <p>
				    This iterator function iterates over a specified list of values.
				 </p>
				 <desc:varparam name="L" kind="ext">
				    a list of values
				 </desc:varparam>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a single parameter.
				 </desc:param>
				 <desc:result>
				    This is an iterator function that iterates
				    over all the values in <@icode{L}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:iterator">
			      <lcode name="iterator"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:lang">
			   <section:unnumbered name="INTRO library:lang">
			      This library contains a number of definitions
			      that are useful when defining <ref:numbered name="Language Definition"/>s.
			   </section:unnumbered>
			   <section:name type="type" name="langtype:redirect">
			      <part name="Description">
				 This language definition type redirect all elements with a specified namespace
				 to an alternate language.
			      </part>
			      <desc:type name="langtype:redirect" ext="true">
				 <desc:param name="name" type="string" kind="ext">
				    the namespace.
				 </desc:param>
				 <desc:param name="langt" kind="ext">
				    the alternate language type.
				 </desc:param>
				 <desc:func name="sys:Init" self="true">
				    <desc:param name="under" type="thread">
				       the underlying language object.
				    </desc:param>
				    <desc:result type="void">
				       Initializes the language object.
				    </desc:result>
				 </desc:func>
				 <desc:func name="sys:Copy" self="true">
				    <desc:result type="myLangType">
				       Returns a copy of the redirect language object for use in another thread.
				    </desc:result>
				 </desc:func>
				 <desc:func name="Walk" self="true">
				    <desc:param name="pass" type='enum["bind1","bind2","exec"]'>
				       the pass being performed.
				    </desc:param>
				    <desc:param name="space" type="string">
				       the name space of the command to be processed.
				       This is usually the same as <@icode{elem.space}/>,
				       but may be different during renaming.
				    </desc:param>
				    <desc:param name="base" type="string">
				       the name base of the command to be processed.
				       This is usually the same as <@icode{elem.base}/>,
				       but may be different during renaming.
				    </desc:param>
				    <desc:param name="elem" type="xdom">
				       the tree node command to be processed.
				       Note that the tag of this node is ignored;
				       <@icode{space}/> and <@icode{base}/> parameters
				       are used instead.
				    </desc:param>
				    <desc:param name="lang">
				       The language object to be used for child elements.
				       This permits two or more languages to be freely mixed.
				       For example consider language object <@icode{l1(l2())}/>
				       where <@icode{l1}/> handles <@verb{"a:"}/> tags
				       and <@icode{l2}/> handles <@verb{"b:"}/> tags.
				       When processing a <@verb{"b:"}/> element
				       <@icode{l1}/> will pass the element on to the
				       underlying <@icode{l2}/>
				       where the value of <@icode{lang}/>
				       will be <@icode{l1(l2())}/>. This permits
				       both <@verb{"a:"}/> and <@verb{"b:"}/> elements
				       to appear as children as a <@verb{"b:"}/> element.
				    </desc:param>
				    <desc:param name="info" type="rec">
				       Useful interpreter information
				       that is passed in.
				       In the bind1 pass, <@icode{info.scope#rec}/> will
				       be the enclosing scope with type <@icode{xdom:element}/>.
				    </desc:param>
				    <desc:result>
				       The result will be the pass result.
				       Any walk of an element with namespace <@icode{name}/>
				       will be sent to a <@icode{langt1}/> language object.
				       For bind1 and bind2 this will be <@icode{null}/>.
				       For exec this will be the result of execution.
				    </desc:result>
				 </desc:func>
			      </desc:type>
			   </section:name>
			   <section:name type="type" name="langtype:rename">
			      <part name="Description">
				 This language definition type redirect all elements with a specified namespace
				 to be processed as an alternate namespace.
			      </part>
			      <desc:type name="langtype:rename" ext="true">
				 <desc:param name="old" type="string" kind="ext">
				    the old namespace.
				 </desc:param>
				 <desc:param name="new" type="string" kind="ext">
				    the new namespace.
				 </desc:param>
				 <desc:func name="sys:Init" self="true">
				    <desc:param name="under" type="thread">
				       the underlying language object.
				    </desc:param>
				    <desc:result type="void">
				       Initializes the language object.
				    </desc:result>
				 </desc:func>
				 <desc:func name="sys:Copy" self="true">
				    <desc:result type="myLangType">
				       Returns a copy of the rename language object for use in another thread.
				    </desc:result>
				 </desc:func>
				 <desc:func name="Walk" self="true">
				    <desc:param name="pass" type='enum["bind1","bind2","exec"]'>
				       the pass being performed.
				    </desc:param>
				    <desc:param name="space" type="string">
				       the name space of the command to be processed.
				       This is usually the same as <@icode{elem.space}/>,
				       but may be different during renaming.
				    </desc:param>
				    <desc:param name="base" type="string">
				       the name base of the command to be processed.
				       This is usually the same as <@icode{elem.base}/>,
				       but may be different during renaming.
				    </desc:param>
				    <desc:param name="elem" type="xdom">
				       the tree node command to be processed.
				       Note that the tag of this node is ignored;
				       <@icode{space}/> and <@icode{base}/> parameters
				       are used instead.
				    </desc:param>
				    <desc:param name="lang">
				       The language object to be used for child elements.
				       This permits two or more languages to be freely mixed.
				       For example consider language object <@icode{l1(l2())}/>
				       where <@icode{l1}/> handles <@verb{"a:"}/> tags
				       and <@icode{l2}/> handles <@verb{"b:"}/> tags.
				       When processing a <@verb{"b:"}/> element
				       <@icode{l1}/> will pass the element on to the
				       underlying <@icode{l2}/>
				       where the value of <@icode{lang}/>
				       will be <@icode{l1(l2())}/>. This permits
				       both <@verb{"a:"}/> and <@verb{"b:"}/> elements
				       to appear as children as a <@verb{"b:"}/> element.
				    </desc:param>
				    <desc:param name="info" type="rec">
				       Useful interpreter information
				       that is passed in.
				       In the bind1 pass, <@icode{info.scope#rec}/> will
				       be the enclosing scope with type <@icode{xdom:element}/>.
				    </desc:param>
				    <desc:result>
				       The result will be the pass result.
				       Any walk of an element with namespace <@icode{old}/>
				       will be processed with the alternate namespace <@icode{new}/>.
				       For bind1 and bind2 this will be <@icode{null}/>.
				       For exec this will be the result of execution.
				    </desc:result>
				 </desc:func>
			      </desc:type>
			   </section:name>
			   <section:name type="func" name="outSpace">
			      <part name="Description">
				 This function is used to convert <@icode{xdom}/> space
				 codes into actual space.
			      </part>
			      <desc:func name="outSpace">
				 <desc:param name="sp" type='enum["empty","space","line","lines","erase"]'>
				    the space code.
				 </desc:param>
				 <desc:result type="string">
				    the actual space.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name type="func" name="walk:attrs">
			   <part name="Description">
			      This special function should only be called
			      within <ref:numbered name="Language Definition"/> types.
			      It walks the attributes of a tree node of type <@icode{xdom}/> which
			      is not an <@icode{xdom:element}/>.
			      The <ref:example name="DocLang"/> example shows
			      a sample use.
			   </part>
			   <desc:func name="walk:attrs">
			      <desc:param name="exp" type="xdom:element">
				    the element whose attributes are to be walked.
			      </desc:param>
			      <desc:result>
				 The pass result.
				 This will be <@icode{null}/> for all passes.
			      </desc:result>
			   </desc:func>
			   </section:name>
			   <section:name type="func" name="walk:elem">
			      <part name="Description">
				 This special function should only be called
				 within <ref:numbered name="Language Definition"/> types.
				 It walks an <@icode{xdom:element}/> tree node.
			      </part>
			      <desc:func name="walk:elem">
				 <desc:param name="elem" type="xdom:element">
				    the element to be walked.
				 </desc:param>
				 <desc:param name="lang">
				    The language object to be used to process the element.
				 </desc:param>
				 <desc:result>
				    The pass result.
				    This will be <@icode{null}/> for bind1 and bind2
				    and the value produced by executing the element
				    in exec.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:lang">
			      <lcode name="lang"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:path">
			   <section:name type="func" name="pathToFile">
			      <desc:func name="pathToFile">
				 <desc:param name="path" type="string">
				    a script path.
				 </desc:param>
				 <desc:result type="string">
				    Result is the fully qualified file path for <@icode{path}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:path">
			      <lcode name="path"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:stdunit">
			   <section:unnumbered name="INTRO library:stdunit">
			      <p>
				 This library defines a set of types for common units.
				 It instantiates the
				 general <@icode{Units}/> type for these specific units.
				 An example of its use can be seen in the <ref:example name="utest"/> example.
				 The base units defined are the following.
			      </p>
			      <list:unordered>
				 <list:item name="meter"> a unit of distance. </list:item>
				 <list:item name="gram"> a unit of mass. </list:item>
				 <list:item name="second"> a unit of time. </list:item>
				 <list:item name="ampere"> a unit of electrical current. </list:item>
				 <list:item name="kelvin"> a unit of temperature. </list:item>
				 <list:item name="candela"> a unit of light intensity. </list:item>
				 <list:item name="mole"> a unit of substance. </list:item>
				 <list:item name="radian"> a unit of angle. </list:item>
				 <list:item name="steradian"> a unit of solid angle. </list:item>
				 <list:item name="bit"> a unit of information. </list:item>
				 <list:item name="dollar"> a unit of currency. </list:item>
			      </list:unordered>
			      <p>
				 These base units plus other scalings (foot versus meter)
				 and derived units (like watts) are defined by the code
				 shown in the next section.
			      </p>
			   </section:unnumbered>
			   <section:unnumbered name="SRC library:stdunit">
			      <lcode name="stdunit"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:typeor">
			   <section:name type="view" name="TypeOr">
			   View that matches a set of types (or views).
			   <desc:view name="TypeOr" ext="true">
			      <desc:varparam name="types" kind="ext">
				 A list of types (or views).
			      </desc:varparam>
			      <desc:func name="sys:Is">
				 <desc:param name="v" type="string">
				    value to test
				 </desc:param>
				 <desc:result type="boolean">
				    The result is <@icode{true}/> if <@icode{v}/> has any
				    of the types in the list of <@icode{types}/>.
				 </desc:result>
			      </desc:func>
			   </desc:view>
			   <part name="Examples">
			      <@code{
			      @x:const BooleanInt := TypeOr[boolean,int,void];
			      @x:var bi~BooleanInt := null;
			      bi := 3;
			      bi := false;
			      }/>
			   </part>
			   </section:name>
			   <section:unnumbered name="SRC library:typeor">
			      <lcode name="typeor"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:unit">
			   <section:unnumbered name="INTRO library:unit">
			      <p>
				 The unit library allows unit type information
				 to be attached to <@icode{float}/> values.
				 For example multiplying an velocity
				 <@icode{meter(100)/second}/> by a time
				 <@icode{second(4)}/> yields <@icode{meter(25)}/>.
				 The <ref:example name="utest"/> example shows more
				 possible forms.
			      </p>
			      <p>
				 The kinds of units are arbitrary.
				 The <ref:unnumbered name="INTRO library:stdunit"/> library defines
				 many common one.
			      </p>
			      <p>
				 Units are checked by keeping track of exponents
				 for each kind of unit.
				 For example velocity (@icode{meter/second}/>)
				 will have non-zero exponents <@icode{[meter=1,second=-1]}/>.
				 Addition, subtraction, and comparison infix operations
				 require that the exponents
				 of both unit operands be equal.
			      </p>
			      <p>
				 Unit values can be mixed in arithmetic operations with
				 <@icode{int}/> and <@icode{float}/> values.
				 Results with all exponents of zero will have type
				 <@icode{float}/>.
			      </p>
			      <p>
				 The following unit multipliers are also defined
				 by this library.
			      </p>
			      <list:unordered>
				 <list:item name="yocto"> 0.001 zepto </list:item>
				 <list:item name="zepto"> 0.001 atto </list:item>
				 <list:item name="atto"> 0.001 femto </list:item>
				 <list:item name="femto"> 0.001 pico </list:item>
				 <list:item name="pico"> 0.001 nano </list:item>
				 <list:item name="nano"> 0.001 micro </list:item>
				 <list:item name="micro"> 0.001 milli </list:item>
				 <list:item name="milli"> 0.001 </list:item>
				 <list:item name="centi"> 0.01 </list:item>
				 <list:item name="deci"> 0.1 </list:item>
				 <list:item name="deka"> 10 </list:item>
				 <list:item name="hecto"> 100 </list:item>
				 <list:item name="kilo"> 1000 </list:item>
				 <list:item name="mega"> 1000 kilo </list:item>
				 <list:item name="giga"> 1000 mega </list:item>
				 <list:item name="tera"> 1000 giga </list:item>
				 <list:item name="peta"> 1000 tera </list:item>
				 <list:item name="exa"> 1000 peta </list:item>
				 <list:item name="zetta"> 1000 exa </list:item>
				 <list:item name="yotta"> 1000 zetta </list:item>
			      </list:unordered>
			      <p>
				 For example a kilometer is written as <@icode{kilo[meter]}/>
				 and a milligram is written as <@icode{milli[gram]}/>.
			      </p>
			   </section:unnumbered>
			   <section:name name="Units">
			      <desc:type name="Units" ext="true">
				 <desc:varparam name="dim" kind="ext">
				    an array of <@icode{string}/>s,
				    one for each base unit.
				 </desc:varparam>
				 <desc:func name="baseUnit">
				    <desc:param name="uname" type="string">
				       the name of one of the base units specified in <@icode{dim}/>.
				    </desc:param>
				    <desc:result>
				    Within the type <@icode{Units["a","b","c"]}/>
				    the result of <@icode{baseUnit("b")}/> will be
				    <@icode{Unit[a=0,b=1,c=0]}/>.
				       </desc:result>
				 </desc:func>
				 <desc:type name="Unit" ext="true">
				    <desc:varparam name="DIM" kind="ext">
				       type exponents
				    </desc:varparam>
				    <desc:func name="sys:Add">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="Unit">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. This type will be the type of the result.
					 The result is the sum of <@icode{a}/> and <@icode{b}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Sub">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="Unit">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. This type will be the type of the result.
					 The result is the value from subtracting <@icode{b}/> from <@icode{a}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Minus">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:result type="Unit">
					  The result will have the same type as <@icode{a}/>.
					  The result value will be the negation of <@icode{a}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Mult">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="TypeOr[Unit,float]">
					  The result type will be the sum of the exponents of
					  <@icode{a}/> and <@icode{b}/>.
					  If all exponents are <@icode{0}/> then the result
					  will have type <@icode{float}/>.
					 The result is the product of <@icode{a}/> and <@icode{b}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Div">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="TypeOr[Unit,float]">
					  The result type will be the result
					  of subtracting <@icode{b}/> exponents from <@icode{a}/>
					  exponents.
					  If all exponents are <@icode{0}/> then the result
					  will have type <@icode{float}/>.
					 The result is the value from dividing <@icode{a}/> by <@icode{b}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Eq">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="boolean">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. 
					  If <@icode{a}/> and <@icode{b}/> have the same
					  value, then the result is <@icode{true}/>,
					  else the result is <@icode{false}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Ne">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="boolean">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. 
					  If <@icode{a}/> and <@icode{b}/> have the same
					  value, then the result is <@icode{false}/>,
					  else the result is <@icode{true}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Less">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="boolean">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. 
					  If <@icode{a}/> is less than <@icode{b}/>,
					  then the result is <@icode{true}/>,
					  else the result is <@icode{false}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:LessEq">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="boolean">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. 
					  If <@icode{a}/> is less than or equal to <@icode{b}/>,
					  then the result is <@icode{true}/>,
					  else the result is <@icode{false}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Greater">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="boolean">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. 
					  If <@icode{a}/> is greater than <@icode{b}/>,
					  then the result is <@icode{true}/>,
					  else the result is <@icode{false}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:GreaterEq">
				       <desc:param name="a" type="Unit">
					  first parameter
				       </desc:param>
				       <desc:param name="b" type="Unit">
					  second parameter
				       </desc:param>
				       <desc:result type="boolean">
					  Both <@icode{a}/> and <@icode{b}/> must have the same
					  type. 
					  If <@icode{a}/> is greater than or equal to <@icode{b}/>,
					  then the result is <@icode{true}/>,
					  else the result is <@icode{false}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Cover">
				       <desc:param name="t" type="type">
					  a type to test.
				       </desc:param>
				       <desc:result type="boolean">
					  The result is <@icode{true}/> if <@icode{a}/> is
					  either <@icode{int}/> or <@icode{float}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Subscript" self="true">
				       <desc:param name="val" type="TypeOr[int,float]">
					  a value.
				       </desc:param>
				       <desc:result type="Unit">
					  Used to specify a value with units.
					  For example, the value 10 feet would be encoded
					  as <@icode{foot(10)}/> which is equivalent
					  to <@icode{10 * foot}/>.
				       </desc:result>
				    </desc:func>
				    <desc:func name="sys:Init" self="true">
				       <desc:param name="val" type="TypeOr[int,float]">
					  an initial value.
				       </desc:param>
				       <desc:result type="void">
					  Initializes a new Unit object.
				       </desc:result>
				    </desc:func>
				    <desc:func name="toString" self="true">
				       <desc:result type ="string">
					  The result is a readable representation
					  of the value and its units.
				       </desc:result>
				    </desc:func>
				    <desc:func name="in" self="true" ext="true" param="false">
				       <desc:param name="t" type="Unit">
				       </desc:param>
				       <desc:result type ="float">
					  The value of <@icode{self}/> and <@icode{t}/>
					  must have the same Unit type.
					  The result of <@icode{meter(3).in[centi[meter]]}/>
					  is equivalent to <@icode{meter(3) / centi[meter]}/>
					  whose result value is <@icode{300.0}/>.
				       </desc:result>
				    </desc:func>
				 </desc:type>
			      </desc:type>
			   </section:name>
			   <section:name name="per">
			      <desc:func name="per" ext="true" param="false">
				 <desc:param name="a" kind="ext">
				    first parameter
				 </desc:param>
				 <desc:param name="b" kind="ext">
				    second parameter
				 </desc:param>
				 <desc:result>
				    The type miles per hour can be coded as <@icode{per[mile,hour]}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name name="exp">
			      <desc:func name="exp" ext="true" param="false">
				 <desc:param name="a" kind="ext">
				    first parameter
				 </desc:param>
				 <desc:param name="b" type="int" kind="ext">
				    second parameter
				 </desc:param>
				 <desc:result>
				    The type cubic meters can be coded as <@icode{exp[meter,3]}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name name="square">
			      <desc:func name="square" ext="true" param="false">
				 <desc:param name="a" kind="ext">
				    first parameter
				 </desc:param>
				 <desc:result>
				    The type square foot can be coded as <@icode{square[foot]}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:name name="cubic">
			      <desc:func name="cubic" ext="true" param="false">
				 <desc:param name="a" kind="ext">
				    first parameter
				 </desc:param>
				 <desc:result>
				    The type cubic centimeters can be coded as <@icode{cubic[centi[meter]]}/>.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:unit">
			      <lcode name="unit"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:unparser">
			   <section:name type="func" name="Unparse">
			   <part name="Description">
			      This function will unparse &xact; scripts and
			      the subset of XML supported by &xact; syntax.
			      It also handles conversions to <ref:numbered name="Pure XML"/>.
			   </part>
			   <desc:func name="Unparse">
			      <desc:param name="tree" type="xdom">
				 parse tree to be unparsed.
			      </desc:param>
			      <desc:nparam name="indent" type="int" default="0" optional="true">
				 number of character positions to skip before starting
				 each line of output.
			      </desc:nparam>
			      <desc:nparam name="incr" type="int" default="3" optional="true">
				 number of additional character positions to indent for
				 each nested level.
			      </desc:nparam>
			      <desc:nparam name="sugar" type="boolean" default="true" optional="true">
				 whether to show sugared forms in the output.
			      </desc:nparam>
			      <desc:nparam name="graph" type="boolean" default="false" optional="true">
				 whether the input should be treated as a graph with sharing and cycles
				 (rather than a tree).
				 If cycles are present and <@icode{graph=false}/>, then <@icode{Unparse}/>
				 will fail (with a stack overflow).
				 For more information see <ref:numbered name="Graphs"/> and the
				 <ref:example name="graph"/> example.
			      </desc:nparam>
			      <desc:nparam name="html" type="boolean" default="false" optional="true">
				 output should be XHTML (rather than plain text).
			      </desc:nparam>
			      <desc:nparam name="partial" type='enum["","start","body","end"]' default='""' optional="true">
				 if <@icode{tree}/> has type <@icode{xdom:element}/>, then
				 this parameter controls which parts of it should be output:
				 only the start tag (<@verb{'"start"'}/>), only the body (<@verb{'"body"'}/>),
				 only the end tag (<@verb{'"end"'}/>), or all parts (<@verb{'""'}/>).
				 each nested level.
			      </desc:nparam>
			      <desc:nparam name="callBack" default="null" optional="true">
				 see below.
				 This parameter is used to generate &xact; documentation.
				 If allows XHTML documentation links to be added for tags, names, infix ops,
				 prefix ops.
			      </desc:nparam>
			      <desc:result type="string">
				 Returns the resulting unparsed text.
			      </desc:result>
			   </desc:func>
			      <p>
				 If the <@icode{callBack}/> parameter is present, it should have the following form.
			      </p>
			      <desc:func name="callBack">
				 <desc:param name="kind" type='enum["preop","inop","name","tag"]'>
				    kind of text given by <@icode{name}/>.
			         </desc:param>
				 <desc:param name="name" type="string">
				    text of name
				 </desc:param>
				 <desc:result type="string">
				    Returns the marked-up (for &xact; documentation an html <@verb{"a"}/> tag
				    is added) form of <@icode{name}/>.
				    If just <@icode{name}/> is returned, the call-back has no net effect.
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:unparser">
			      <lcode name="unparser"/>
			   </section:unnumbered>
			</section:library>
			<section:library name="library:walk">
			   <section:name type="iterator" name="Walk">
			      <desc:func name="Vals" ext="true">
				 <p>
				    This function iterates over a <@icode{xdom}/> tree.
				 </p>
				 <desc:param name="t" type="xdom" kind="ext">
				    an xdom tree.
				 </desc:param>
				 <desc:param name="act">
				    the iterator body function.
				    It takes a two parameters, the first of type <@icode{enum["before","between","after"]}/> and
				    the second of type <@icode{xdom}/>.
				 </desc:param>
				 <desc:result>
				    This is an iterator function walks the tree in standard order.
				    For every node in the tree the body function <@icode{act}/> is called
				    twice, once when a node is first
				    visited (<@icode{"before"}/>) and
				    once when the node is about to be left
				    (<@icode{"after"}/>).
				    It is called an
				    additional time (<@icode{"between"}/>) for <@icode{xdom:element}/> (after
				    the attributes but before the body)
				    and  for <@icode{xdom:call}/> (after the function but before the parameters).
				 </desc:result>
			      </desc:func>
			   </section:name>
			   <section:unnumbered name="SRC library:walk">
			      <lcode name="walk"/>
			   </section:unnumbered>
			</section:library>
		     </section:top>
</section:top>
